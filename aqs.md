# 思想

## 六个操作

### 抢锁

state:

​	锁未被占用 state=0

​	锁已被占用 state=1

公平锁

非公平锁

​	两者大多情况一样的，只有一个临界点不一样，占有锁的线程释放锁，这个时候刚好有线程过来

锁未被占用

​	并发

​	CAS 保证同一时刻只有一个线程能够修改标志位

​	汇编指令

锁已被占用

​	一、进来的线程是持有锁的线程（重入锁）

​		记录重入次数，解锁需要解锁相应的次数

​	二、不是持有锁的线程

​		1.直接运行结束（不合适）

​		2.保存下来，等待唤醒执行

### 释放锁

state恢复

重入次数

唤醒队列中的线程

### 入队

基于CLHLock 单向，单aqs是双向

1.如果队列中没有节点，head，tail都只向它

​	aqs创建两个节点，第一个节点是持有锁的线程占用了，第二个节点是线程二对应的节点

2.如果队列中已经有节点了

​	从尾部插入

### 出队

​	1.正常情况下，从头部

​	2.非正常情况下，从中间，尾部

​		cancelAcquire(node);

### 阻塞

​	park

### 唤醒

​	unpark

## 三套机制

### state

0 1

### waitStatus

10 -1-2-3

### 队列

## 队列

CLHLock

MCSlock