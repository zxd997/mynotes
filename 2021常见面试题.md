# 常见面试题

## Java基础

* **jdk8的新特性**

* **== 和 equals()区别**

  ==：对于基本数据类型比较的是值是否相等；

  ​		对于引用数据类型比较的是内存地址是否相同；

  equals(): 只有引用类型有意义；属于Object的方法，当中就是==比较，但是如String类重写了此方法，比较的是值

* **两个对象的hashCode()相同，则equals()也一定为true吗**

  两个对象equals返回true，那么hashcode一定相等；两个对象的hashcode相等，那么equals不一定为true。
  重写equals()方法，则hashCode()方法也必须重写，这样才能保证equals()方法返回true时，hashcode的值相等。

* **java是值传递还是引用传递**

  1.这个题目出的不严谨，但是很好(因为涉及了 Java 内存模型)
  2.就 Java 语言本身来说，只有值传递，没有引用传递。
  3.根据 值传递，引用传递的定义来说：
          Java 中的基本类型，属于值传递。
          Java 中的引用类型，属于引用传递。
          Java 中的 String 及包装类，属于特殊群体，作为形参时，由于每次赋值都相当于重新创建了对象，因此看起来像值传递，但是其特性已经破坏了，值传递、引用传递的定义。因此他们属于引用传递的定义，却表现为值传递。

* **关键字**

  * **final**

  1、用来修饰一个引用
   如果引用为基本数据类型，则该引用为常量，该值无法修改；
   如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
   如果引用时类的成员变量，则必须当场赋值，否则编译会报错。

   2.用来修饰一个方法
      当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

  3.用来修饰类
   当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。

  * **transient**

    1.只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。

    2.被transient修饰的变量不参与对象的序列化和反序列化

    3.static修饰的变量无论有没有被transient修饰都不参与序列化和反序列化，因static修饰的变量属于类，不属于对象。

    2的例外：

    ​	java中有两种序列化的方式。

    1. 实现Serializable接口。

       ​	不需要默认空参构造器。

       ​	有两种方式：

       ​	a，无需任何，所有没被transient修饰的字段都参与序列化

       ​	b，编写私有无返回方法，指定哪些字段参与。

       ```java
       	private void writeObject(ObjectOutputStream oos) throws IOException {
       		// oos.defaultWriteObject();
       		oos.writeObject(name);
       		oos.writeObject(isbn);
       	}
       
       	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
       		// ois.defaultReadObject();
       		name = (String) ois.readObject();
       		isbn = (String) ois.readObject();
       	}
       ```

    2. 实现Externalizable接口。

       ​	需要默认空参构造器。

       ```java
       public interface Externalizable extends java.io.Serializable {
        
           void writeExternal(ObjectOutput out) throws IOException;
       
          
           void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
       }
       ```

       需要实现两个方法来指定需要序列化的字段。被transient修饰也没有

* **java中 Math.round（-1.5）等于多少**

  -1。四舍五入。

* **java中操作字符串的类有哪些，之间的区别**

  String 声明的是不可变的对象，每次操作都会生成新的 String 对象

  StringBuffer、StringBuilder 可以在原有对象的基础上进行操作,前者线程安全适合多线程中，后者线程不安全，多在单线程中使用

* **String str = “i" 和 String str = new String（"i"）一样吗**

  通过字面量的方式。先看常量池中是否已经存在相同字符串 (equals())，若存在，返回常量池中的引用。若不存在，在常量池中创建字符串对象并返回其引用。

  通过显式创建字符串对象的方式。先在堆中创建一个对象。再看常量池中是否已经存在相同字符串，若存在，直接返回堆中的引用。若不存在，在常量池中创建字符串对象并返回堆中的引用。

* **如何实现字符串的反转**

  ```java
      public static String reverse1(String str) {
          return new StringBuilder(str).reverse().toString();
      }
      public static String reverse2(String str) {
          String rs = "";
          char[] chars = str.toCharArray();
          for (int i = 0; i < chars.length; i++) {
              rs = chars[i] + rs;
          }
          return rs;
      }
      public static String reverse3(String str) {
          String reverse = "";
          int length = str.length();
          for (int i = 0; i < length; i++) {
              reverse = str.charAt(i) + reverse;
          }
          return reverse;
      }
  ```

  

* **String类常用的方法有哪些**

  equals：字符串是否相同
  equalsIgnoreCase：忽略大小写后字符串是否相同
  compareTo：根据字符串中每个字符的Unicode编码进行比较
  compareToIgnoreCase：根据字符串中每个字符的Unicode编码进行忽略大小写比较
  indexOf：目标字符或字符串在源字符串中位置下标
  lastIndexOf：目标字符或字符串在源字符串中最后一次出现的位置下标
  valueOf：其他类型转字符串
  charAt：获取指定下标位置的字符
  codePointAt：指定下标的字符的Unicode编码
  concat：追加字符串到当前字符串
  isEmpty：字符串长度是否为0
  contains：是否包含目标字符串
  startsWith：是否以目标字符串开头
  endsWith：是否以目标字符串结束
  format：格式化字符串
  getBytes：获取字符串的字节数组
  getChars：获取字符串的指定长度字符数组
  toCharArray：获取字符串的字符数组
  join：以某字符串，连接某字符串数组
  length：字符串字符数
  matches：字符串是否匹配正则表达式
  replace：字符串替换
  replaceAll：带正则字符串替换
  replaceFirst：替换第一个出现的目标字符串
  split：以某正则表达式分割字符串
  substring：截取字符串
  toLowerCase：字符串转小写
  toUpperCase：字符串转大写
  trim：去字符串首尾空格

* **抽象类必须有抽象的方法吗**

  no，但是如果一个类包含抽象方法，则该类必须是抽象类

* **普通类和抽象类的区别**

  抽象类不能被实例化；

  抽象方法不能被private、final、static修饰

* **接口和抽象类有什么区别**

  抽象类：可以有非抽象的方法，可以提高代码的复用性，这是抽象类的优势；

  接口：只能有抽象方法；

  java单继承、多实现。

* **java中IO流分为几种**

  字节bai流类
  抽象父类： InputStream,OutputStream

  字符流
  抽象父类：Reader, Writer

  一般操作流的步骤：
  （1）创建源
  （2）选择流
  （3）操作流（读取|写出）
  （4）释放资源

* **BIO、NIO、AIO有什么区别**

  Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。

  举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（**同步阻塞**）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（**同步非阻塞**）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（**异步非阻塞**）。

  BIO-同步阻塞 适合活动链接数不高

  NIO-同步非阻塞

  AIO-（NIO 2 jdk 7）异步非阻塞

  [详细内容参考](https://blog.csdn.net/m0_38109046/article/details/89449305)

* **创建对象的几种方式**

  创建对象的方式：new、反射、clone()，反序列化、第三方库

* **Java 数组最大长度**
  库函数里的数组最大数量都是指定为Integer.MAX_VALUE-8。按注释所说，8是为对象头预留的，对象头在64位虚拟机下占16个字节，8一定不是指字节数，如果指的是字长，那么这个数字应该是可以更小的。

* **String有最大长度限制吗？**

  String 的长度是有限制的。

  - 编译期的限制：字符串的UTF8编码值的字节数不能超过65535，字符串的长度不能超过65534；

  - 运行时限制：字符串的长度不能超过2^31-1，占用的内存数不能超过虚拟机能够提供的最大值。

    

## JVM

* **JVM内存模型**

  1.堆
  Java虚拟机所管理内存中的最大的一块，在虚拟机启动时创建，被所有线程共享。
  2.虚拟机栈

  （其中有局部变量表

  操作数栈

  动态链接）

  虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。虚拟机栈式线程所私有的，独有的，随着线程的创建而创建。每一个线程执行的方法，为该栈中的栈帧，即每一个方法对应一个栈帧。
  3.方法区

  Person p = new Person()

  方法区 栈  堆

  方法区是所有线程所共享的内存区域，在虚拟机启动的时候创建。保存类信息，静态变量
  4.程序计数器
  程序技术器占用的内存空间很小，在任意时刻，一个处理器只会执行一条线程中的指令，因此，为了线程切换后能够恢复到正确的执行位置，每条线程需要有一个独立的程序计数器（线程私有）。如果线程正在执行Java方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则这个计数器为空。
  5.本地方法栈
  如果当前线程执行的方法是Native类型，这些方法就会在本地方法栈中执行

* **JVM三种运行模式：**

  　　解释模式（Interpreted Mode）：只使用解释器（-Xint强制JVM使用解释模式），执行一行JVM字节码就编译一行为机器码。（可以马上看到效果，但是运行过程比较慢）

    　　编译模式（Compiled Mode）：（也叫即时编译技术JIT）只使用编译器（-Xcomp强制JVM使用编译模式），先将所有JVM字节码一次性编译为机器码，然后一次性执行所有机器码。（启动时间比较长，但是运行过程快）

    　　混合模式（Mixed Mode）：依然使用解释模式执行代码，但是对于一些“热点”代码采用编译模式，JVM一般采用混合模式执行代码。即引入了两种即使编译器：C1 C2。C1编译器称为client编译器，面向对启动性能有要求的用户端，编译时间段，优化策略简单；C2称为Serve驳岸一起面向对峰值性能有要求的服务器端，编译时间长，优化策略复杂。具体的在编译热点方法的时候先采用C1编译器，热点方法中的热点方法会被C2编译器再次编译。

  c1优化弱，但是更快编译。c2，编译久，优化后效率更高。

  hotspot是两者都用。解释器可以先不用等待代码全部编译好，省去等待时间，而随着时间，代码编译好，转化为编译执行。并且当编译执行的优化失败，可以回到解释执行。

  什么时候用编译执行？热点探测。栈上替换（OSR）编译。

  热点？hotspot VM通过基于计数器进行热点探测：

  方法调用计数器：统计方法调用次数

  回边计数器：统计循环体执行的循环次数

* **GC机制和原理**[详细参考](https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html)

  - 发生区域

    堆

  - 堆内存结构

    在JDK1.8之后，堆的永久区取消了由元空间取代

    Java将堆内存分为：新生代 8:1:1（Eden、S0、S1(Survivor)三个区、老年代

    1.为什么有Survivor区？减少对象进入老年代，减少FullGC。这样设计可以使对象每熬过一次GC，增加一个年龄，到达设定值才进入老年代。

    2.为什么Survivor是两个？根据其原理，可解决内存碎片导致内存不连续的问题。

    3.为什么Survivor不是多个？会导致每个Survivor都很小，容易满。

  - 堆内存上对象的分配与回收

    可设置-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝。

    YGC（MinorGC）：频繁发生，速度快

    ​	发生在新生代。

    ​	Eden空间不足的时候发生；

    ​	一次长一岁，默认15岁，去老年代。-XX:MaxTenuringThreshold设置晋升年龄。

    ​	动态对象年龄判定：

    ​		如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该对象年龄的对象即可晋升		到老年代，不必要等到-XX:MaxTenuringThreshold。

    ​	空间分配担保：

    ​		发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次		Full GC（老年代GC），如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次		Minor GC，如果不允许，则改为进行一次Full GC。

    *（可忽略）MajorGC：很少发生，速度慢

    ​	发生在老年代。发年代空间不足时发生。

    FullGC：很少发生，速度慢

    ​	看作包含以上两种GC。发生Full GC一般都会有一次Minor GC。

    ​	1.System.gc()方法的调用，此方法是建议JVM进行Full GC,虽然只是建议而非一定

    ​	2.老年代的内存空间不足

    ​	3.当Minor GC时，老年代的剩余空间小于历次从新生代往老年代中移的对象的平均内存空间大小时

    ​	4.方法区内存不足：JDK7包含7有永久代

    ​	5.堆中分配很大的对象。虽有足够空间，但是没有足够大的连续空间。

  - 标记阶段算法

    为了解决**JVM如何判定一个对象是否应该被回收**

    引用计数法：
    是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。

    优点：实现简单，垃圾对象便于标识；判定效率高，回收没有延迟性

    缺点：1、需要计数器额外占用空间；2、需要加减越算，增加时间复杂度3、（最重要的）无法解决循环引用的问题。所以java中没有使用该算法。

    可达性分析算法：

    以根节点GC Roots为起始点，按照从上而下的方式搜索被根对象集合所连接的目标对象是否可达。

  - 清楚阶段算法

    标记-清除算法（Mark-Sweep）：

    第一阶段：从引用根节点开始标记所有被引用的对象，

    第二阶段：遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。

    缺点：执行效率不稳定，会因为对象数量增长，效率变低，清除后内存不连续，产生内存碎片。需要维护一个空闲列表。

    优点：简单

    复制（Copying）算法：

    复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

    优点：没有标记和清除过程，实现简单，运行高效；空间连续，不会有碎片问题。
    缺点：需要两倍内存空间。如果系统中存活对象特别多，这个算法也不理想。

    标记-压缩（标记-整理，Mark-Compact）算法：

    标记-整理算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，

    第一阶段从根节点开始标记所有被引用对象，

    第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

    优点：内存连续，分配新对象，jvm只需要持有一个内存的起始地址即可。不必内存减半
    缺点：相比其他效率最差。移动对象时，如果对象被其他对象引用，则还需要调整引用的地址；移动过程中，需要暂停用户应用程序。即STW

    最好的算法？
    分代收集算法：
    年轻代：朝生夕死，存活率低，回收频繁。复制算法
    老年代：多数都是存活的，回收不频繁，标记清除或标记清除和标记整理混合使用
    Mark阶段的开销与存活对象数量成正比；
    Sweep阶段的开销与所管理的区域的大小成正相关。
    Compact阶段的开销与存活对象的数据成正比。
    增量收集算法：分阶段标记-清除和标记-整理，不用Stop the World
    缺点是线程转换，上下文转换，成本上升，系统吞吐量下降
    分区算法
    将堆空间划分为连续的独立的小空间，每个小区间独立使用独立回收
    好处：可以控制一次回收多少个小区间

* **垃圾收集器**

  ![](https://img2020.cnblogs.com/blog/1863208/202005/1863208-20200518221710647-576582447.png)

  * **1、Serial收集器：**

    Serial收集器是**一个单线程的垃圾收集器**，并且在执行垃圾回收的时候需要 **Stop The World**。虚拟机运行在**Client模式**下的默认新生代收集器。Serial收集器的优点是简单高效，对于限定在单个CPU环境来说，Serial收集器没有多线程交互的开销。缺点：交互较强的应用不行，STW久

    复制算法

    **2、Serial Old收集器：**

    Serial Old是Serial收集器的老年代版本，也是**一个单线程收集器**。主要也是给在Client模式下的虚拟机使用。在Server模式下存在主要是做为CMS垃圾收集器的后备预案，**当CMS并发收集发生Concurrent Mode Failure时使用。**

    标记-整理

    **3、ParNew收集器：**

    ParNew是Serial收集器的**多线程**版本，新生代是并行的（多线程的），可以使用参数：**-XX：UseParNewGC使用该收集器，使用 -XX：ParallelGCThreads可以限制线程数量。**

    复制算法

    **4、Parallel Scavenge垃圾收集器：**

    Parallel Scavenge是一种新生代收集器，而且是**并行的多线程收集器。**Paralle收集器特点是更加关注吞吐量（吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值）。可以通过**-XX:MaxGCPauseMillis参数控制最大垃圾收集停顿时间；通过-XX:GCTimeRatio参数直接设置吞吐量大小；通过-XX:+UseAdaptiveSizePolicy参数可以打开GC自适应调节策略，**该参数打开之后虚拟机会根据系统的运行情况收集性能监控信息，动态调整虚拟机参数以提供最合适的停顿时间或者最大的吞吐量。**自适应调节策略**是Parallel Scavenge收集器和ParNew的主要区别之一。

    复制算法

    **5、Parallel Old收集器：**

    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

    **6、CMS（Concurrent Mark Sweep）收集器（并发标记清除）**

  CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种老年代收集器，通常与**ParNew**一起使用。

  **CMS的垃圾收集过程分为4步：**

  - **初始标记**：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。

    - **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。

  - **重新标记**：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。

    - **并发清除**：和用户线程并发执行的，基于标记结果来清理对象。

     ![img](https://img2020.cnblogs.com/blog/1863208/202005/1863208-20200518221735413-1771145268.png)

     

     

    那么问题来了，**如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？**

    答：不会的，在并发标记阶段其实还包括了一次并发的**预清理阶段**，虚拟机会主动**等待年轻代发生垃圾回收**，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。

    #### **CMS垃圾回收器的优缺点分析：**

    CMS以降低垃圾回收的停顿时间为目的，很显然其具有并发收集，停顿时间低的优点。

    #### **缺点主要包括如下：**

    - **对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。

  - 收集过程中会产生**浮动垃圾**，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。

    - **标记-清除方式会产生内存碎片**，可以使用参数**-XX：UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。参数**-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

    接下来，我们先看下上边介绍的浮动垃圾是怎么产生的吧。

    **浮动垃圾：**

    由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了**“Floating Garbage”**，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，**并发收集器一般需要20%的预留空间**用于这些浮动垃圾。

    并发标记阶段如果产生新垃圾，无法对其标记。只能下次gc了。（Remark是把之前标记为垃圾的，修改为不是垃圾，而不是垃圾的，没有处理）

    **7、G1（Garbage-First）收集器：**

  G1收集器将新生代和老年代取消了，取而代之的是**将堆划分为若干的区域**，每个区域都可以根据需要扮演新生代的Eden和Survivor区或者老年代空间，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。

  通过**将JVM堆分为一个个的区域（region）**,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的region。**

    **G1收集器的特点：**

    - **并行与并发**：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。

  - **分代收集**：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。

    - **空间整合**：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
    - **可预测的停顿**：能够建立可以预测的停顿时间模型，预测停顿时间。

    **和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：**

    - 初始标记
    - 并发标记
    - 最终标记
    - 筛选回收

    其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。

    java -XX:+PrintCommandLineFlags -version

    jdk1.8默认的新生代垃圾收集器：Parallel Scavenge，老年代：Parallel Old

    jdk1.9 默认垃圾收集器G1

* **JVM中几种classloader，为什么会有多种**

  启动类加载器（Bootstrap ClassLoader 根加载器）

  ​	它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

  扩展类加载器（Extension ClassLoader）

  ​	它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。继承抽象类ClassLoader

  应用程序类加载器(Application ClassLoader也叫系统类加载器 System ClassLoader)

  ​	负责加载用户类路径(classpath)上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

  ​	还可以自定义类加载器

  1.加载

  ​	指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象

      类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
      
      通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。

  2.链接

  ​	验证：

  ​	准备：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。

  ​	解析

  3.初始化

  ​	初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。

* **类加载 过程**

  类加载器加载Class大致要经过如下8个步骤：

  检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
  如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
  请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
  请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
  当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
  从文件中载入Class，成功后跳至第8步。

* **类记载机制**

  全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
  双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
  缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

* **什么是双亲委派机制？介绍一下运作流程，双亲委派模型的好处，什么情况下需要破坏双亲委派模型**

  * 双亲委派机制：

  <img src="https://images2015.cnblogs.com/blog/731716/201607/731716-20160701132830015-300463923.png" style="zoom:50%;" />

  上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。

  * 好处

    1.避免类的重复加载（父加载器加载过，就不用再加载）

    2.可以防止核心API库被随意篡改。

  * 破坏双亲委派模型

    打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。

    使用线程上下文类加载器

    第一次被破坏

    ​	因为双亲委派模型是JDK1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时就已经存在，所以在面对已存在的用户自定义类加载器的实现代码时，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，这是源于虚拟机进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。

    第二次被破坏

    ​	如JNDI服务，使用线程上下文类加载器

    第三次被破坏

    ​	由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。

* **java的引用类型**

  强引用StrongReference：类似：Object o = new Object(),只有引用在，就不会被回收

  软引用SoftReference 内存溢出前，考虑回收。即，内存不足即回收。不一定是oom才回收

  弱引用WeakReference 垃圾收集器收集就回收。

  虚引用PhantomReference 无法获得一个对象实例。唯一目的是，它被收集时收到一个系统通知

* **常见的JVM调优工具有哪些**

  Jconsole : jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。详细说明参考这里

  JProfiler：商业软件，需要付费。功能强大。详细说明参考这里

  VisualVM：JDK自带，功能强大，与JProfiler类似。推荐。

* **常见的JVM调优方法有哪些，可以具体到调整哪个参数，调成什么值**

  * 查出问题

    内存：检查内存释放情况、老年代年轻代分配是否合理、内存泄露、垃圾回收算法是否合理

    线程：线程状态监控、死锁。

    热点分析：

    ​	CPU热点：那些方法占用CPU时间多、

    ​	内存热点：那些对象占用内存多

  * 解决问题

    * 将新对象预留在新生代

    * 将大对象放入老年代：因为大对象进入新生代，放不下会导致小对象进入老年代，扰乱了GC。

    * 设置对象进入老年代的合适年龄

    * 稳定与震荡的堆大小。稳定的堆大小对垃圾回收是有利的，获得一个稳定堆大小的方法就是设置 -Xmx 和 -Xms 一样的值。不稳定的堆也不是木有用处，让堆大小在一个区间内震荡，在系统不需要使用大内存时压缩堆空间，使 GC 应对一个较小的堆，可以加快单次 GC 的速度。基于这种思想，JVM 提供了两个参数用于压缩和扩展堆空间，参数如下：

      -XX：MinHeapFreeRatio：设置堆空间最小空闲比例，默认是 40 ，当堆空间的空闲比例小于这个值时，JVM 便会扩展堆空间

      -XX：MaxHeapFreeRatio：设置堆空间的最大空闲比例，默认是 70，当堆空间的空闲比例大于这个值时，JVM 便会压缩堆空间，得到一个较小的堆

      注意：当 -Xms 和 -Xmx 相等时，-XX：MinHeapFreeRatio 和 -XX：MaxHeapFreeRatio 这两个参数无效

    * 吞吐量优先设置

      机器配置是 4G 内存 和 32 核 CPU，配置参数如下：

      -Xms3800m  -Xmx3800m（堆的初始值和最大值一样） 

      -Xmn2g（新生代大小）

      -Xss128k（线程栈大小，减少它使剩余的系统内存支持更多的线程） 

      -XX：+UseParallelGC（新生代使用并行回收收集器）

       -XX：ParallelGCThreads=20（垃圾回收的线程数）

       -XX：+UseParallelOldGC （老年代使用并行回收收集器）

    * 使用大页案例

      使用大的内存分页可以增强 CPU 的内存寻址能力，从而提高系统的性能，参数设置如下：

      -XX：LargePageSizeInBytes：设置大页的大小

    * 降低停顿案例

      为了降低应用软件在垃圾回收时的停顿，首先考虑的使用关注系统停顿的 CMS 回收器，为了减少 Full GC 的次数，应尽可能将对象预留在新生代，新生代 Minor GC 的成本远远小于老年代的 Full GC

      -Xms3800m  -Xmx3800m（堆的初始值和最大值一样） 

      -Xmn2g（新生代大小）

      -Xss128k（线程栈大小，减少它使剩余的系统内存支持更多的线程）

      -XX：ParallelGCThreads=20（垃圾回收的线程数）

      -XX：+UseConcMarkSweepGC（老年代使用 CMS 收集器）

       -XX：+UseParNewGC（新生代使用并行收集器）

      -XX：SurvivorRatio=8（设置 eden ： survivor = 8 : 1）

      -XX：TargetSurvivorRatio（设置 survivor 的使用率为 90%，默认是50%，提高了survivor 区的使用率，当存放的对象超过这个数值，则对象会向老年代压缩）

      -XX：MaxTenuringThreshold=31（设置年轻对象晋升到老年代的最大年龄是31，默认是15，设为31是尽可能地将对象留在新生代

    * 常用JVM设置参数

      1、JIT编译参数

      JVM 的 JIT（Just-In-Time）编译器，可以在运行时将字节码编译成本地代码，从而提高函数的执行效率。参数设置如下

      -XX：CompileThreshold：JIT 编译的阀值，当函数的调用超过这个值时，JIT 就将字节码编译成本地机器码。在 client 模式下，取值是 1500，在 server 模式下，取值是 10000

      2、堆快照（堆 Dump）
      	-XX：+HeapDumpOnOutOfMemoryError（开启堆快照）

      ​	-XX：HeapDumpPath=C:/m.hprof（保存文件到哪个目录）

      3、错误处理

      系统发生 OOM 错误时，JVM 在错误发生时运行一段第三方脚本，重置系统，设置参数如下：

      -XX：OnOutOfMemoryError=C:\reset.bat


      4、获取 GC 信息
    
      获取 GC 信息是 java 应用程序调优最重要的一环，下面介绍一些常用的设置参数：
    
      -XX：+PrintGC（-verbose：gc）：输出打印简要的 GC 信息，包括 GC 前的堆栈情况和 GC 后的堆栈大小和堆栈的总大小
    
      -XX：+PrintGCDetails：输出打印详细的 GC 信息，不仅包括基本信息，还给出了新生代、老年代和永久区各自的 GC 信息
    
      -XX：+PrintGCTimeStamps：额外输出 GC 发生的时间，可以推断出 GC 的频率和间隔
    
      -XX：+PrintTenuringDistribution  -XX：MaxTenuringThreshold=18：查看新生代晋升老年代的实际阀值（-XX：+PrintTenuringDistribution），设置的最大年龄为18（ -XX：MaxTenuringThreshold=18）
    
      -XX：+PrintHeapAtGC：每次 GC 时都会打印堆的详细使用情况，输出量很巨大。它分为两个部分：GC 前的堆信息和 GC 后的堆信息，这里包含了新生代、老年代和永久区的使用大小和使用率，还包括了新生代中 eden 区和 survivor 区的使用情况
    
      -XX：+PrintGCApplicationStoppedTime：应用程序在 GC 发生时的停顿时间
    
      -XX：+PrintGCApplicationConcurrentTime：应用程序在 GC 停顿期间的执行时间
    
      -Xloggc：C:/gc.log：将 GC 日志信息输出到具体位置的文件中，便于日后日志分析
    
      注意：详细的 GC 信息是进行 JVM 调优的重要参考信息，可以根据 GC 日志，设置合理的堆大小及相关垃圾回收器的参数


      5、类和对象跟踪
    
      JVM 提供了一组参数，用于获取系统运行时加载、卸载类的信息，参数设置如下：
    
      -XX：TraceClassLoading：跟踪类加载情况
    
      -XX：TraceClassUnloading：跟踪类的卸载情况
    
      -verbose：class：相当于同时设置  -XX：TraceClassLoading 和 -XX：TraceClassUnloading 两个参数
    
      -XX：+PrintClassHistogram：打印运行时实例的信息，当设置此参数后，使用 Ctrl +    Break 会输出系统内类的统计信息，从左到右依次显示了序号、实例数量、总大小和类名等信息


      6、控制GC
    
      -XX：DisableExplicitGC：禁止 GC 操作，即禁止在程序中使用 System.gc() 触发 Full GC
    
      -Xnoclassgc：禁止类的回收
    
      -Xingc：增量式的 GC ，增量式的 GC 使用特定的算法让 GC 线程和应用程序线程交叉执行，从而减少应用程序因 GC 产生的停顿时间
    
      -Xverify：none：关闭类校验器
    
      -XX：+UseLargePages：启用大页，使用大页后，内存分页的表项就会减少，从而提升CPU从虚拟内存地址映射到物理内存地址的能力
    
      -XX：LargePageSizeInBytes：指定大页的大小

* **int a = 1;jvm如何取得a的值**

  1 a作为类的成员变量，存放于方法区中；1保存在堆(Heap)的实例中
  2 a作为方法局部变量，存放于Java虚拟机栈(JVM Stacks)的局部变量表中；1也保存在栈内存中

* **逃逸分析（JDK7以后默认开启）**

  逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。

  如果开启JVM逃逸分析可以优化JVM，但是目前不成熟。

  ​	一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

  ​	二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。节省对内存减少GC。

  ​	三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

  ​			标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

  在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

  public static void main(String[] args) {
     alloc();
  }

  private static void alloc() {
     Point point = new Point（1,2）;
     System.out.println("point.x="+point.x+"; point.y="+point.y);
  }
  class Point{
      private int x;
      private int y;
  }
  以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。

  以上代码，经过标量替换后，就会变成：

  private static void alloc() {
     int x = 1;
     int y = 2;
     System.out.println("point.x="+x+"; point.y="+y);
  }
  可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

  标量替换为栈上分配提供了很好的基础。
  
  

  在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，

  -XX:+DoEscapeAnalysis ： 表示开启逃逸分析

  -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis

* **jvm调优调的哪些参数？我说初始堆大小和最大堆大小一样，问这样有什么好处**

  主要调：堆的初始和最大内存（堆的最小和最大空闲时间）（新生代的大小）、线程栈的大小、垃圾收集器的选择。

  设置初始和最大堆一样的好处：

  ​	一般情况下，在生产环境中，初始堆大小-Xms与最大堆大小-Xmx被设置为相等。假设如果在生产环境中，初始堆大小-Xms与最大堆大小-Xmx是不等的，那么JVM就会根据堆内存的使用情况，动态的向操作系统申请内存，扩大或者是缩小，以-Xmx和-Xms的值为上下界，这里的每一次调整都会产生一定的系统开销，虽然做到了动态申请堆大小的能力，不过生产环境中，很少说一台机器跑好多个JAVA程序，一般情况下都是一对一，那么动态申请调整堆大小就没有意义了，因为不管内存申请的多还是少，都只是这个JAVA程序在用，不需要给其他的程序腾出空间，相反的，如果把初始堆大小-Xms与最大堆大小-Xmx设置成不相等，那么反而画蛇添足，因为如果初始堆大小-Xms与最大堆大小-Xmx不相等，那么就会需要申请空间时，而每次申请空间，就会产生相应的系统开销，同时如果一开始堆大小是-Xms，会增加程序运行时进行垃圾回收的次数，降低程序的性能。

  

## 容器

* **Collection和Collections有什么区别**

  ![](https://img-blog.csdnimg.cn/20200410211055784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTM2NTc4,size_16,color_FFFFFF,t_70)

  1、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。

  List，Set，Queue接口都继承Collection。
  直接实现该接口的类只有AbstractCollection类，该类也只是一个抽象类，提供了对集合类操作的一些基本实现。List和Set的具体实现类基本上都直接或间接的继承了该类。

  2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等），大多数方法都是用来处理线性表的。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

* **HashMap和HashTable区别**

  * 父类不同

    HashTable：继承自Dictionary（已被废弃）

    HashMap：继承自AbstractMap类

    不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。

    Hashtable比HashMap多提供了elments() 和contains() 两个方法。

        elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。

       contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。

  * null值问题

    HashTable：不能有null值null键

    HashMap：可以有一个null值，支持null键。

    当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

  * 线程安全性

    HashTable：线程安全，它的每个方法中都加入了Synchronize方法。

    ​	但基本由于性能问题，已被弃用。ConcurrentHashMap因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。

    HashMap：单线程使用性能更好，多线程不安全，还可能造成死锁。

  * 遍历方式不同

  * 初始容量不同

    Hashtable的初始长度是11，之后每次扩充容量变为之前的2n+1（n为上一次的长度）

    而HashMap的初始长度为16，之后每次扩充变为原来的两倍

    创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。

  * 计算hash值方式不同

    为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置

    Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。 然而除法运算是非常耗费时间的。效率很低

    HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。

* **HashMap数据结构和实现原理，以及有什么并发问题**

  [详细参考](https://juejin.cn/post/6844903646212128776)

  * 公共：

    * 负载因子：0.75

    ​		为什么是0.75？ 

    ​			时间和空间的权衡。如果为1，增加了hash冲突，增加了红黑树的复杂度。如果为0.5，hash冲突降低了，浪费了更多的空间。

    ​			源码上说了，负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。

    * 初始容量：16 

    ​		若指定容量，变成他的2的指数次幂。（为了性能，尽量提前预估大小，而且要考虑实际元素大小要 小于 HashMap算得2指数次幂*0.75，否则容易触发扩容机制）

    ​		为什么2的指数次幂容量，及二倍扩容？

    ​			计算索引：当 length 为 2 的次幂时，num & (length - 1) = num % length 等式成立，位运算更高效

    * 懒加载（延时加载）

      put()调用的时候先判断初始数组是否为空，如果为空，则初始化。

  * 1.7

    * 插入方式：头插

      为什么头插？考虑一般使用不扩容的情况时，头插方便，不需要遍历链表。

      隐患：并发出现循环链表

    * 数据结构：数组+链表

    * 节点：Entry

    * hash()

      ​	**高低位扰动计算**，降低了了发生hash冲突的几率。

      ```java
          h ^= (h >>> 20) ^ (h >>> 12);
          return h ^ (h >>> 7) ^ (h >>> 4);
      ```

    * 这是什么？index = hash&length-1，所有hash低位相同，高位不同导致hash冲突，性能保险，再次进行一种算法的hash运算。

    * put（）过程：

      		1.判断当前数组是否需要初始化。
       	  2.如果 key 为空，则 put 一个空值进去。
       	  3.根据 key 计算出 hashcode。
       	  4.根据计算出的 hashcode 定位出所在桶。
       	  5.如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。
       	  6.如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。
       		7.当调用 addEntry 写入 Entry 时需要判断是否需要扩容。
       	    如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。
       	    而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。

    * get（）过程：

      ```
      首先也是根据 key 计算出 hashcode，然后定位到具体的桶中。
      判断该位置是否为链表。
      不是链表就根据 key、key 的 hashcode 是否相等来返回值。
      为链表则需要遍历直到 key 及 hashcode 相等时候就返回值。
      啥都没取到就直接返回 null 。
      ```

      

    * 扩容时机：

      ​		先判断扩容，后插入。

      ​			为什么这个顺序？因为JDK7头插，如果先插入后扩容，而扩容时还要遍历元素，重新整顿，没必要先插入。

      ​		(size>=threshold)&&(null !=table[bucketIndex])
      ​        1、 存放新值的时候当前已有元素的个数必须大于等于阈值
      ​		2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）

    * rehash：这个定义指扩容时重新计算索引

      扩容导致时，将原有的对象重新计算hash值重新的分配并加入新的桶内。

      （再一次调用int i = indexFor(e.hash,newCapacity);

      目的：为了解决数量增多，导致一些链表太长，时间复杂度O(n)的问题

      

  * 1.8

    * 插入方式：尾插

      ​	为什么尾插？因为在resize()的时候，头插方式，同一Entry链上的元素，重新计算索引位置时，顺序有变，导致出现并发问题，形成循环链表。尾插，扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。

      ​	但put和get没有锁机制，依然无法保证多线程情况下的安全。

    * 数据结构：数组+链表+红黑树

      ​	红黑树时间复杂度O(logn)

    *  节点：Node

    * 计算hash：

      首先，在高位扰动方面，只是简单的h = h ^ (h >>> 16)，没有再做那么多的扰动，就得到了hash值。其次，去掉了indexFor这个专门定位的函数，而是在put,get等操作中直接定位，可以看到这些函数中都有这两行
      我自己的理解是，由于用红黑树优化了冲突很多，链很长的情况，所以没必要做那么多的高低位扰动了。有了冲突也可以处理。

    * put（）过程：

    		1.判断当前桶为空，为空初始化。
    		
    		2.计算key的hashcode，定位具体的桶，若痛为null，则没有hash冲突，直接创建一个新桶即可。
    		
    		3.若桶不为空（hash冲突），则比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e，
    		
    		4.若不相等，如果当前桶为红黑树，按照红黑树方式写入数据。
    		
    		5.如果当前桶为链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面
    		
    		6.接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。
    		
    		7.如果在遍历过程中找到 key 相同时直接退出遍历。
    		8.如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。
    		9.最后判断是否需要进行扩容。（插入后的size>阈值）

    * get（）过程:

      ```
      首先将 key hash 之后取得所定位的桶。
      如果桶为空则直接返回 null 。
      否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。
      如果第一个不匹配，则判断它的下一个是红黑树还是链表。
      红黑树就按照树的查找方式返回值。
      不然就按照链表的方式遍历匹配返回值。
      ```

    * 扩容时机：

      先插入，后判断扩容

      ​	为什么这个顺序？因为JDK8尾插，如果先扩容后，而插入时还要遍历元素，扩容还要遍历一遍，没必要遍历两次啊。

      两种情况下扩容：1,初始化时。2,插入后的size>阈值。

    * rehash：

      不需要重新计算hash，而是巧妙的使用了：原来的hash值&原数组长度 来判断：

      即e.hash&oldCap 如果结果等于0位置相同，如果不等于0，位置等于原来索引+原数组长度

    * 树化机制

      阈值：当前链表长度大于8

      ​	为什么是8？源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。

      条件：先判断table的长度是否大于64 && 链表长度超过阈值

    * 树退化机制

      阈值：当前树节点数小于6

      ​	为什么是6？避免来回转化。

      ​	因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。

      条件：

      ​	1.remove():

      ​	在红黑树的root节点为空 或者root的右节点、root的左节点、root左节点的左节点为空时 说明树都比较小了

      ​	2.resize():

      ​	当红黑树节点元素小于等于6时(只有resize()才用到了这个6)

* **ConcurrentHashMap的原理**

  * 1.7

    是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。

    分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。

  * 1.8

    抛弃了原有的 Segment 分段锁，节点改为Node，数组加链表+红黑树，而采用了 CAS + synchronized 来保证并发安全性。

* **如何决定使用HashMap还是TreeMap**

  HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。
  HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。
  HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。
  都是非线程安全。

* **LinkedHashMap的应用**

  数据结构：可以认为是HashMap+LinkedList，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序。

  迭代顺序：插入顺序。如果启动了访问顺序，最近访问的会排到尾部。

  put():用hashMap的put方法，

  ​	插入新值

  ```java
  //中间调用了自己重写了的newNode()
  Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
          LinkedHashMap.Entry<K,V> p =
              new LinkedHashMap.Entry<K,V>(hash, key, value, e);
              //将节点插入链尾
          linkNodeLast(p);
          return p;
      }
  
  ```

  ​	更新值

  ```java
  void afterNodeAccess(Node<K,V> e) { 
    //将值覆盖
  ```

  ​	此外，HashMap.put中的putVal 还调用了afterNodeInsertion()方法，在HashMap中这个方法是空的，但LinkedHashMap重写了

  ```java
  void afterNodeInsertion(boolean evict) { // possibly remove eldest
          LinkedHashMap.Entry<K,V> first;
          if (evict && (first = head) != null && removeEldestEntry(first)) {
              K key = first.key;
              removeNode(hash(key), key, null, false, true);
          }
      }
  //removeEldestEntry：LinkedHashMap的此方法是返回false，需要子类继承以便扩展。
  ```

  

  get()：重写了HashMap的get，实现了LRU

  ```java
  public V get(Object key) {
      Node<K,V> e;
      if ((e = getNode(hash(key), key)) == null)
          return null;
      if (accessOrder)
          afterNodeAccess(e);
      return e.value;
  }
  ```

  remove()：

  ​	也是调用的HashMap的remove，过程中调afterNodeRemoval，此方法在LinkedHashMap中实现了

  应用：LruCache 不经常使用的删掉

  ```java
      @Override
  		protected boolean removeEldestEntry(Entry<K, V> eldest) {
          return this.size() > this.maxSize;
      }
  ```

  

* **HashSet实现原理**

  ```
  * HashSet
  
    内部用HashMap的key存储，而value为一个object
  	add()是调用内部HashMap的put
    不保证迭代的顺序，不可重复，无索引，允许为null但只能有一个.
    操作都是基于HashMap的
  
  * LinkedHashSet 
  
    内部中LinkedHashMap，Entry节点，双向链表
  
    保证迭代的顺序，不可重复，无索引，允许为null但只能有一个
  
  * TreeSet
  
    SortedSet接口的唯一实现类，是基于二叉树实现的。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。
  	自然排序：指已经实现了Comparable接口的类的插入，如String，Integer
  	定制排序：指手动实现了Comparable接口。
    保证迭代的顺序，不可重复，无索引，不允许为null值，
  ```

* **ArrayList和LinkedList区别**

  * ArrayList:

    基于数组。

    优点：get、set 通过索引定位更快 O(1)

    缺点：add、remove。改变了一些元素的下标，要执行System.arrayCopy

    ArrayList需要一份连续的内存空间，LinkedList不需要连续的内存空间（特别地，当创建一个ArrayList集合的时候，连续的内存空间必须要大于等于创建的容量）

    fail-fast的保护机制：

    之所以会抛出ConcurrentModificationException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示可能发生了并发修改！所以，在使用Java的集合类的时候，如果发生ConcurrentModificationException，优先考虑fail-fast有关的情况，实际上这可能并没有真的发生并发，只是Iterator使用了fail-fast的保护机制，只要他发现有某一次修改是未经过自己进行的，那么就会抛出异常。

    扩容：初始容量为10。

    ​	第一次add minCapacity=10     newCapacity = 10

    ​	第二次add minCapacity = 2	 newCapacity = 10

    ​	第十次add minCapacity = 10   newCapacity = 10

    ​	第十一add 触发grow() （未必add多少个） minCapacity = n	newCapacity =  1.5倍扩容，若newCapacity<minCapacity 则newCapacity = minCapacity，详细：

    ```java
        private void grow(int minCapacity) {
            // overflow-conscious code
            int oldCapacity = elementData.length;
            int newCapacity = oldCapacity + (oldCapacity >> 1);
            if (newCapacity - minCapacity < 0)
                newCapacity = minCapacity;
            if (newCapacity - MAX_ARRAY_SIZE > 0)
                newCapacity = hugeCapacity(minCapacity);
            // minCapacity is usually close to size, so this is a win:
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
    
        private static int hugeCapacity(int minCapacity) {
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            return (minCapacity > MAX_ARRAY_SIZE) ?
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
        }
    ```

    扩容倍数： grow()是有逻辑判断的，刚开始偶数1.5倍（奇数1.5倍-1），后续逻辑也可能是扩容更多。

  * LinkedList：

    基于双向链表。

    优点：add、remove 、对于两端的操作。

    双向链表查找index位置的节点时，有一个加速动作：若index < 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。

    额外常用方法：

    ​	添加：

    ​		push(E)：添加到头

    ​		add(E)：添加到尾

    ​		offer(E): =add()

    ​	获取：

    ​		pop(): 获取头元素，并移除。如果获取的为null，报错。

    ​		poll(): 获取头元素，并移除。如果为null，就返回null，

    ​		peek()：获取头元素，不移除，如果为null，就返回null

    ​		remove():=pop()

    ### 时间复杂度

    | 操作     | 数组 | 链表 |
    | -------- | ---- | ---: |
    | 随机访问 | O(1) | O(N) |
    | 头部插入 | O(N) | O(1) |
    | 头部删除 | O(N) | O(1) |
    | 尾部插入 | O(1) | O(1) |
    | 尾部删除 | O(1) | O(1) |
    | 随机插入 | O(n) | O(n) |
    | 随机删除 | O(n) | O(n) |

    ​	后两个是数组更快，原因是，当数据量大的时候，system.arraycopy的效率要比每次插入LinkedList都需要从端查找index和分         配节点node来的更快。

* **如何实现数组和List之间的转化**

  ```java
  //三种方式：
  public void test5() {
      Integer[] arr = {1, 2, 4};
      List<Integer> list = Arrays.asList(arr);
      Integer[] toArray = list.toArray(new Integer[0]);
    	Collections.addAll(list, arr);
  }
  ```

* **ArrayList和Vector区别**

  Vector：

  ​	数据结构一样。

  ​	线程安全：很多方法都有synchronized修饰。

  ​	扩容：2倍扩容，也支持按capacityIncrement（构造器传入）增长量扩容。

* **Array和ArrayList区别**

  ​	性能：对于引用类型来说没差别；但对于基本数据类型，List会引起拆箱和装箱，频繁操作影响效率。

  ​	数据结构：Array是本地程序数据结构；ArrayList是基于Array的一个java集合类。

  ​	功能：Array固定长度。ArrayList实现了自动扩容，并且封装了更多的方法。

* **Queue中poll()和remove()区别**

  poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

* **哪些集合类是线程安全的**

  * 早期：

  Vector：就比Arraylist多了个同步化机制（线程安全）。

  Hashtable：就比Hashmap多了个线程安全。

  Stack：栈，也是线程安全的，继承于Vector。

  * Collections包装方法：

    List<E> synArrayList = Collections.synchronizedList(new ArrayList<E>());

    Set<E> synHashSet = Collections.synchronizedSet(new HashSet<E>());

    Map<K,V> synHashMap = Collections.synchronizedMap(new HashMap<K,V>());

    Collections针对每种集合都声明了一个线程安全的包装类，在原集合的基础上添加了锁对象，集合中的每个方法都通过这个锁对象实现同步。(synchronized修饰方法)

  * java.util.concurrent包下的集合类

  ​	1.ConcurrentHashMap

  ConcurrentHashMap和HashTable都是线程安全的集合，它们的不同主要是加锁粒度上的不同。HashTable的加锁方法是给每个方法加上synchronized关键字，这样锁住的是整个Table对象。而ConcurrentHashMap是更细粒度的加锁 
  在JDK1.8之前，ConcurrentHashMap加的是分段锁，也就是Segment锁，每个Segment含有整个table的一部分，这样不同分段之间的并发操作就互不影响 
  JDK1.8对此做了进一步的改进，它取消了Segment字段，直接在table元素上加锁，实现对每一行进行加锁，进一步减小了并发冲突的概率

  2.CopyOnWriteArrayList和CopyOnWriteArraySet

  它们是加了写锁的ArrayList和ArraySet，锁住的是整个对象，但读操作可以并发执行

  3.

  除此之外还有ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque等，至于为什么没有ConcurrentArrayList，原因是无法设计一个通用的而且可以规避ArrayList的并发瓶颈的线程安全的集合类，只能锁住整个list，这用Collections里的包装类就能办到
  
* **迭代器Iterator是什么？怎么使用，有什么特点？**

  定义：

  ​	首先说一下迭代器模式，它是 Java 中常用的设计模式之一。用于顺序访问集合对象的元素，无需知道集合对象的底层实现。 

  Iterator 是可以遍历集合的对象，为各种容器提供了公共的操作接口，隔离对容器的遍历操作和底层实现，从而解耦。

  缺点是增加新的集合类需要对应增加新的迭代器类，迭代器类与集合类成对增加。

  ```java
      boolean hasNext();
      E next();
      default void remove(){...}
  ```

  使用：

  ```java
  public class LinkList<T> implements Iterable<T>{
      @Override
      public Iterator<T> iterator() {
          return new MyLinkIterator();
      }
        private class MyLinkIterator implements Iterator{
  
          private Node n;
  
          public MyLinkIterator() {
              this.n = head;
          }
  
          @Override
          public boolean hasNext() {
              return n.next != null;
          }
  
          @Override
          public Object next() {
              n = n.next;
              return n.item;
          }
      }
      public void print() {
        //即可使用Iterable.forEach
          forEach(t -> {
              if (t instanceof Integer) {
                  System.out.println((Integer) t);
              }
          });
      }
  }
  ```

  ArrayList的Iterator：（fail-fast机制：ConcurrentModificationException）

  ​	Iterator的特点：Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。

  ```java
  public boolean hasNext()
  {
      return cursor != size;//当cursor不等于size时，表示仍有索引元素
  }
  public E next() //返回下一个元素
      {
              checkForComodification();
              int i = cursor;
              if (i >= size)
                  throw new NoSuchElementException();
              Object[] elementData = ArrayList.this.elementData;
              if (i >= elementData.length)
                  throw new ConcurrentModificationException();
              cursor = i + 1;
              return (E) elementData[lastRet = i];
      }
  在next()方法中有一个checkForComodification()方法，其实现为：
  final void checkForComodification()
    {
         if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
  可以看到，该函数是用来判断集合的修改次数是否合法。
  
  　　在集合内部维护一个字段modCount用于记录集合被修改的次数，每当集合内部结构发生变化(add,remove，set)时，modCount+1。
  
  　　在迭代器内部也维护一个字段expectedModCount，同样记录当前集合修改的次数，初始化为集合的modCount值。当我们在调用Iterator进行遍历操作时，如果有其他线程修改list会出现modCount!=expectedModCount的情况，就会报并发修改异常java.util.ConcurrentModificationException。下面为示例代码：
    public static void main(String[] args)
      {
           ArrayList<String> aList=new ArrayList<String>();
           aList.add("bbc");
           aList.add("abc");
           aList.add("ysc");
           aList.add("saa");
           System.out.println("移除前："+aList);
      
           Iterator<String> it=aList.iterator();
           while(it.hasNext())
           {
               if("abc".equals(it.next()))
               {
                  aList.remove("abc");  //如果我们只使用迭代器来进行删除，则不会出现并发修改异常错误。改为：it.remove();      
               }
           }
           System.out.println("移除后："+aList);
    }
  迭代器的remove（）：
    public void remove()
       {
              if (lastRet < 0)
                  throw new IllegalStateException();
              checkForComodification();
              try {
                  ArrayList.this.remove(lastRet);
                  cursor = lastRet;
                  lastRet = -1;
                  expectedModCount = modCount;
              } catch (IndexOutOfBoundsException ex) {
                  throw new ConcurrentModificationException();
              }
       }
  ```

  

* **Iterator和ListIterator的区别**

  1.Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。
  2.Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。
  3.ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。
  4.ListIterator 可以使用set()方法替换它访问过的最后一个元素.
  5.ListIterator 可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.
  ListIterator ArrayList的实现双向遍历：实现ListIterator的类，可以自定义指针位置来实现的。

* **怎么确保一个集合不能被修改**

  （1）通过 Collections. unmodifiableCollection(Collection c)

  ```java
  public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
          return new UnmodifiableCollection<>(c);
      }
  static class UnmodifiableCollection<E> implements Collection<E>, Serializable {
          private static final long serialVersionUID = 1820017752578914078L;
  
          final Collection<? extends E> c;
  
          UnmodifiableCollection(Collection<? extends E> c) {
              if (c==null)
                  throw new NullPointerException();
              this.c = c;
          }
  
          public int size()                   {return c.size();}
          public boolean isEmpty()            {return c.isEmpty();}
          public boolean contains(Object o)   {return c.contains(o);}
          public Object[] toArray()           {return c.toArray();}
          public <T> T[] toArray(T[] a)       {return c.toArray(a);}
          public String toString()            {return c.toString();}
  
          public Iterator<E> iterator() {
              return new Iterator<E>() {
                  private final Iterator<? extends E> i = c.iterator();
  
                  public boolean hasNext() {return i.hasNext();}
                  public E next()          {return i.next();}
                  public void remove() {
                      throw new UnsupportedOperationException();
                  }
                  @Override
                  public void forEachRemaining(Consumer<? super E> action) {
                      // Use backing collection version
                      i.forEachRemaining(action);
                  }
              };
          }
  
          public boolean add(E e) {
              throw new UnsupportedOperationException();
          }
          public boolean remove(Object o) {
              throw new UnsupportedOperationException();
          }
  
          public boolean containsAll(Collection<?> coll) {
              return c.containsAll(coll);
          }
          public boolean addAll(Collection<? extends E> coll) {
              throw new UnsupportedOperationException();
          }
          public boolean removeAll(Collection<?> coll) {
              throw new UnsupportedOperationException();
          }
          public boolean retainAll(Collection<?> coll) {
              throw new UnsupportedOperationException();
          }
          public void clear() {
              throw new UnsupportedOperationException();
          }
  ```

  （2）通过Arrays.asList创建的集合

  ​	实际是创建了一个Arrays内部的ArrayList 他继承抽象类AbstractList，AbstractList当中修改的方法 都throw new UnsupportedOperationException();

## 异常

* **throw和throws区别**

  throw是语句抛出一个异常。如 throws new Exception();

  throws是方法可能抛出异常的声明。用在声明方法上。

* **final、finally、finalize有什么区别**

  final：关键字

  finally，try...catch体中，一定会执行的代码块。

  finalize：Object的一个方法。是gc之前被finalizer线程调用一次。一般用于整理系统资源或者执行其他整理工作。

* **try-catch-finally中，如果catch中return了，finally还是执行吗**

  try-catch-finally中return的执行情况：
  在try中没有异常的情况下try、catch、finally的执行顺序 try --- finally

  如果try中有异常，执行顺序是try --- catch --- finally

  如果try中没有异常并且try中有return这时候正常执行顺序是try ---- finally --- return

  如果try中有异常并且try中有return这时候正常执行顺序是try----catch---finally--- return

  总之 finally 永远执行！

  **注意的地方**：

  不管有没有异常，finally中的代码都会执行

  当try、catch中有return时，finally中的代码依然会继续执行

  finally是在return后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。

  如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。

  finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值

* **常见的异常类有哪些**

  异常非常多，Throwable 是异常的根类。

  Throwable 包含子类 错误-Error 和 异常-Exception 。

  Error：程序无法处理的系统错误，编译器不做检查；

  Exception：程序可以处理的异常，捕获后可能恢复；

  总结：前者是程序无法处理的错误，后者是可以处理的异常。

  Exception 又分为 一般异常和运行时异常 RuntimeException。

  运行时异常不需要代码显式捕获处理。

   

  下图是常见异常类及其父子关系：
  Throwable
  |　　├ Error  

  |　　│ ├ NoClassDefFoundError

  |　　│ ├ StackOverflowError

  |　　│ ├ OutOfMemoryError

  |　　│ 

  |　　├ Exception  

  |　　│ ├ CloneNotSupportedException

  |　　│ ├ DataFormatException

  |　　│ ├ InterruptedException

  |　　│ ├ IOException

  |　　│ ├ ClassNotFoundException

  |　　│ ├ RuntimeException 

  |　　│    ├ NumberFormatException

  |　　│    ├ ClassCastException

  |　　│    ├ ConcurrentModificationException

  |　　│    ├ IllegalArgumentException

  |　　│    ├ IndexOutOfBoundsException

  |　　│    ├ NoSuchElementException

  |　　│    ├ NullPointerException

  |　　│　└ SecurityException

  |　　│ └  SQLException

## 网络

* **http状态码，以及301和302区别**

  | 分类 | 分类描述                                       | 常见                                                         |
  | :--- | :--------------------------------------------- | ------------------------------------------------------------ |
  | 1**  | 信息，服务器收到请求，需要请求者继续执行操作   | 100，101                                                     |
  | 2**  | 成功，操作被成功接收并处理                     | 200请求成功                                                  |
  | 3**  | 重定向，需要进一步的操作以完成请求             | 300多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择；301永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替临时移动。302，与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
  | 4**  | 客户端错误，请求包含语法错误或无法完成请求     | 400 Bad Request 客户端请求的语法错误，服务器无法理解；401 Unauthorized 请求要求用户的身份认证402 Payment Required 保留，将来使用。403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源 405 Method Not Allowed 客户端请求中的方法被禁止 |
  | 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 | 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 |

* **forward和redirect的区别**

  1、请求方不同

  redirect：客户端发起的请求

  forward：服务端发起的请求

  2、浏览器地址表现不同

  redirect：浏览器地址显示被请求的

  forward：浏览器地址不显示被请求的url

* **简述tcp和udp的区别**

  tcp：传输控制协议）是面向连接的协议

  udp：用户数据报协议

  1.基于连接与无连接；
  2.对系统资源的要求（TCP较多，UDP少）；
  3.UDP程序结构较简单；
  4.流模式与数据报模式 ；

  5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

  使用场景：比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频。ping命令也是udp。原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

* **tcp为什么三次握手，两次不行吗**

  建立连接的三次握手：

  ​	第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

  第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我

  第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

  TCP建立连接要进行3次握手，而断开连接要进行4次
  第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；

  第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；

  第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；

  第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。

  由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。

  1.**三次握手的作用有两个**

  （1）让Client和Server双方都知道双方可以发送和接收到对方的消息；

  （2）避免网络堵塞时，Client以为没有连接上，发送多次请求，而Server会为前面多次无效请求创建连接，造成资源浪费；

  2.**具体说明**

  2.1 **三次握手确认双方都能接收和发送消息**

  （1）第一次握手，Client发送给Server：你好，能听到我的声音吗？；    》server如果收到，Server知道了能接收到client发送的消息

  （2）第二次握手，Server发送给Client ：你好，我能听到你的声音（确认ACK），你能听到我的声音吗？     》Client如果能收到，说明Client知道Server能发送和接收消息；现在还有一点没有确认就是Server不知道Client能否接收Server发送消息？Client的可能电话设置静音了，听不到Server的声音。这样沟通就无效了。所以需要第三次握手。

  （3）第三次握手，Client发送给Server：我能听到你的声音，我告诉你一个重大的密码……     》Server收到，Server知道client具体接收能力；

   

  2.2**避免Server 为无效的连接创建资源**

  Client发送给Server请求连接，如果因为网络堵塞，这个请求阻塞在传输过程中，Client以为没有发过去，又发了一个请求。第一个请求又发送到了服务器，Server又会创建两个连接，第一个连接是无效的，客户端不会通过这个连接去发送消息，这样就造成了服务器资源的浪费。所以需要三次握手，确定连接是否是有效连接。

  高级解释：为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
  如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

* **说一下tcp的粘包是怎么产生的**

  TCP粘包是什么？
  粘包发生在发送或接收缓冲区中；应用程序从缓冲区中取数据是整个缓冲区中有多少取多少；那么就有可能第一个数据的尾部和第二个数据的头部同时存在缓冲区，而TCP是流式的，数据无边界，这时发生粘包。


  二、TCP粘包的产生
  1.发送方产生粘包
  采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了；

  2.接收方产生粘包
  接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包；（放数据的速度 > 应用层拿数据速度）

  TCP粘包解决方案
  目前应用最广泛的是在消息的头部添加数据包长度，接收方根据消息长度进行接收；在一条TCP连接上，数据的流式传输在接收缓冲区里是有序的，其主要的问题就是第一个包的包尾与第二个包的包头共存接收缓冲区，所以根据长度读取是十分合适的；

  1.解决发送方粘包
  （1）发送产生是因为Nagle算法合并小数据包，那么可以禁用掉该算法；
  （2）TCP提供了强制数据立即传送的操作指令push，当填入数据后调用操作指令就可以立即将数据发送，而不必等待发送缓冲区填充自动发送；
  （3）数据包中加头，头部信息为整个数据的长度（最广泛最常用）；
  2.解决接收方粘包
  （1）解析数据包头部信息，根据长度来接收；
  （2）自定义数据格式：在数据中放入开始、结束标识；解析时根据格式抓取数据，缺点是数据内不能含有开始或结束标识；
  （3）短连接传输，建立一次连接只传输一次数据就关闭；（不推荐）

* **OSI的7层模型都有哪些**

  [参考](https://blog.csdn.net/meism5/article/details/90414270)

  物理层 数据链路层 网络层 传输层 会话层 表示层 应用层

* **get和post的请求有哪些区别**

  [参考](https://www.cnblogs.com/mjtabu/p/12090419.html)

* **如何实现跨域、JSONP实现原理**

  [参考](https://www.cnblogs.com/fundebug/p/10329202.html)

  ****

## Spring

* **spring有哪些优势**

  [向Spring大佬低头——大量源码流出解析 ](https://www.sohu.com/a/230831412_505825)

  Spring是一种轻量级框架，旨在提高开发人员的开发效率以及系统的可维护性。

  - 由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。

* **StringIOC**

  控制反转，一种设计思想。

  利用java的反射来创建对象。

  程序中原本手动创建对象的控制权交给Spring来管理，依赖关系也交给Spring管理。当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。大大增加了项目的可维护性且降低了开发难度。

* **StringAOP**

  面向切面编程。能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。

  Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。

  当然也可以使用AspectJ，Spring AOP中已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了AOP。

  **Spring AOP和AspectJ AOP有什么区别？**

  Spring AOP是属于运行时增强，而AspectJ是编译时增强。Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。

  Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。

  如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。

* **Spring中Bean的作用域**

  1. singleton，prototype，
  2. request，session，application，websocket（这几个只有在web开发中用到）

* **Spring单例模式下的线程不安全问题**

  因为成员变量是存放在堆内存中，而堆内存又是线程共享的，这就造成了线程安全问题

  因为Spring中的Bean默认是单例的，所以在定义成员变量时也有可能会发生线程安全问题。

  解决：1使用prototype 2使用ThreadLocal

* **Spring中Bean的生命周期**

  根据配置进行Bean的实例化 ->属性注入 -> 调用初始化的一些方法 -> 可以使用 -> 容器关闭，则调用销毁的方法，销毁

* **Spring5比Spring4做了哪些改进**

  1.响应式编程：新的spring-webflux模块

  2.函数式web框架

  3.至少要是jdk8版本。和J2EE 7

* **Spring中BeanFactory和FactoryBean的区别**

  都是一个接口。

  **BeanFactory**:

  ​	也就是IOC容器或对象工厂.所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。

  ​	是spring中比较原始的Factory。如XMLBeanFactory就是一种典型的BeanFactory。原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。 

  ​	注意，BeanFactory 只能管理单例（Singleton）Bean 的生命周期。它不能管理原型(prototype,非单例)Bean 的生命周期。这是因为原型 Bean 实例被创建之后便被传给了客户端,容器失去了对它们的引用。

  ​	这是一个工厂模式的工厂接口。

  ​	BeanFactory最常见的实现类为XmlBeanFactory，可以从classpath或文件系统等获取资源。可以加载xml的配置文件

  \1. XmlBeanFactory通过Resource装载Spring配置信息冰启动IoC容器，然后就可以通过factory.getBean从IoC容器中获取Bean了。
  \2. 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一个调用时。
  \3. 对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean时直接从IoC容器缓存中获取Bean。

  

  **FactoryBean**:

  ​	这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 

  **ApplicationContext**:

  [参考](https://www.cnblogs.com/xiaoxi/p/5846416.html)

  ​	ApplicationContext接口,如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的躯体了，ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置实现。通常建议比BeanFactory优先。

  BeanFactorty接口提供了配置框架及基本功能，但是无法支持spring的aop功能和web应用。而ApplicationContext接口作为BeanFactory的派生，因而提供BeanFactory所有的功能。而且ApplicationContext还在功能上做了扩展，相较于BeanFactorty，ApplicationContext还提供了以下的功能： 

  （1）MessageSource, 提供国际化的消息访问 
  （2）资源访问，如URL和文件 
  （3）事件传播特性，即支持aop特性
  （4）载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层 

  ApplicationContext：是IOC容器另一个重要接口， 它继承了BeanFactory的基本功能， 同时也继承了容器的高级功能，如：MessageSource（国际化资源接口）、ResourceLoader（资源加载接口）、ApplicationEventPublisher（应用事件发布接口）等。

  注意：

  下面对吗？

  start》

  如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况：
  1）如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该bean，并且将实例化的bean放在一个线程安全的 ConcurrentHashMap 结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取 。
  2）如果bean的scope是singleton的，并且lazy-init为true，则该bean的实例化是在第一次使用该bean的时候进行实例化 。
  3）如果bean的scope是prototype的，则该bean的实例化是在第一次使用该Bean的时候进行实例化 。
  是不是就是说，使用ApplicationContext作为Spring Bean的工厂类，并不总是在容器启动时，一次性创建了所有的Bean。

  《〈end 还是下面对

  应该是，IOC容器的启动其实主要是里面的refresh方法。主要完成IOC容器的初始化。具体获取bean则要通过getBean方法。Bean的实例化就是你上面的情况。如果是BeanFactory的方式，那实例化Bean的过程发生在getBean的时候，也就是容器初始化之后。而ApplicatonContext的方式的话，AbstractApplicatonContext中的refresh加上了对lazy-init懒加载属性的判断处理。3种判断情况。总体来说就和你说的是那样的。如果是单例不设置懒加载属性的话，那就是在refresh中会进行bean的初始化。而设置了的话，就在getBean的时候进行初始化。

  **三、二者区别**

  1.BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。

  BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。
  应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。

  2.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）

  3.beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。

  **四、总结**

  作用：
  \1. BeanFactory负责读取bean配置文档，管理bean的加载，实例化，维护bean之间的依赖关系，负责bean的声明周期。

  \2. ApplicationContext除了提供上述BeanFactory所能提供的功能之外，还提供了更完整的框架功能：
  a. 国际化支持
  b. 资源访问：Resource rs = ctx. getResource(“classpath:config.properties”), “file:c:/config.properties”
  c. 事件传递：通过实现ApplicationContextAware接口

  \3. 常用的获取ApplicationContext

  FileSystemXmlApplicationContext：从文件系统或者url指定的xml配置文件创建，参数为配置文件名或文件名数组，有相对路径与绝对路径。

  ```
  ApplicationContext factory=new FileSystemXmlApplicationContext("src/applicationContext.xml");
  ApplicationContext factory=new FileSystemXmlApplicationContext("E:/Workspaces/MyEclipse 8.5/Hello/src/applicationContext.xml");
  ```

  ClassPathXmlApplicationContext：从classpath的xml配置文件创建，可以从jar包中读取配置文件。ClassPathXmlApplicationContext 编译路径总有三种方式：

  ```
  ApplicationContext factory = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
  ApplicationContext factory = new ClassPathXmlApplicationContext("applicationContext.xml"); 
  ApplicationContext factory = new ClassPathXmlApplicationContext("file:E:/Workspaces/MyEclipse 8.5/Hello/src/applicationContext.xml");
  ```

  XmlWebApplicationContext：从web应用的根目录读取配置文件，需要先在web.xml中配置，可以配置监听器或者servlet来实现

  ```
  <listener>
  <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>
  ```

  或

  ```
  <servlet>
  <servlet-name>context</servlet-name>
  <servlet-class>org.springframework.web.context.ContextLoaderServlet</servlet-class>
  <load-on-startup>1</load-on-startup>
  </servlet>
  ```

  这两种方式都默认配置文件为web-inf/applicationContext.xml，也可使用context-param指定配置文件

  ```
  <context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>/WEB-INF/myApplicationContext.xml</param-value>
  </context-param>
  ```

* **Spring中使用到的设计模式**

  1.工厂设计模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。

  2.代理设计模式：Spring AOP功能的实现。

  3.单例设计模式：Spring中的bean默认都是单例的。

  4.模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类，它们就使用到了模板模式。

  5.包装器设计模式：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

  6.观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。

  7.适配器模式：Spring AOP的增强或通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller。

  。。。

* **@Component和@Bean的区别是什么**

  1.作用对象不同。@Component注解作用于类，而@Bean注解作用于方法。

  2.@Component注解通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用@ComponentScan注解定义要扫描的路径）。@Bean注解通常是在标有该注解的方法中定义产生这个bean，告诉Spring这是某个类的实例，当我需要用它的时候还给我。

  3.@Bean注解比@Component注解的自定义性更强，而且很多地方只能通过@Bean注解来注册bean。比如当引用第三方库的类需要装配到Spring容器的时候，就只能通过@Bean注解来实现。

* **将一个类声明为Spring的bean的注解有哪些？**

  我们一般使用@Autowired注解去自动装配bean。而想要把一个类标识为可以用@Autowired注解自动装配的bean，可以采用以下的注解实现：

  1.@Component注解。通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪一个层，可以使用@Component注解标注。

  2.@Repository注解。对应持久层，即Dao层，主要用于数据库相关操作。

  3.@Service注解。对应服务层，即Service层，主要涉及一些复杂的逻辑，需要用到Dao层（注入）。

  4.@Controller注解。对应Spring MVC的控制层，即Controller层，主要用于接受用户请求并调用Service层的方法返回数据给前端页面。

* **Bean的装配**

  在Spring中有三种装配方式：

  1.在xml中显示装配

  2.在java中显示装配

  3.隐式自动装配bean：byName和byType（会自动从上下文找）

  @Autowired 可以在属性上和set方法上，前提ioc容器中有，先byType，如果有多个用@qualifier()byName。

  @Resource先byName，找不到byType，还是找不到就完蛋了 

* **Spring事务管理的方式有几种？**

  1.编程式事务：在代码中硬编码（不推荐使用）。

  2.声明式事务：在配置文件中配置（推荐使用），分为基于XML的声明式事务和基于注解的声明式事务。

* **Spring事务中的隔离级别有哪几种？**

  在TransactionDefinition接口中定义了五个表示隔离级别的常量：

  ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql默认采用的REPEATABLE_READ隔离级别；Oracle默认采用的READ_COMMITTED隔离级别。

  ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

  ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

  ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

  ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

* **Spring事务中有哪几种事务传播行为？**

  在TransactionDefinition接口中定义了八个表示事务传播行为的常量。

  支持当前事务的情况：

  PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。

  PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。

  PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）。

  不支持当前事务的情况：

  PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。

  PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。

  PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。

  其他情况：

  PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于PROPAGATION_REQUIRED。

* **spring有哪些常用注解？（我一紧张说了springboot的注解）**

  @Controller
  
  @RequestMapping
  
  @Resource和@Autowired
  
  @PathVariable
  
  @requestParam
  
  @ResponseBody
  
  @Component
  
  @Repository
  
  springboot独有的：
  
  @RestController
  
  @SpringBootApplication
  
  @ConfigurationProperties
  
  @Enable...
  
  

## SpringMVC

* **springMVC原理**

  1.客户端（浏览器）发送请求，直接请求到DispatcherServlet。

  2.DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler。

  3.解析到对应的Handler（也就是我们平常说的Controller控制器）。

  4.HandlerAdapter会根据Handler来调用真正的处理器来处理请求和执行相对应的业务逻辑。

  5.处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View。

  6.ViewResolver会根据逻辑View去查找实际的View。

  7.DispatcherServlet把返回的Model传给View（视图渲染）。

  8.把View返回给请求者（浏览器）。

## SpringBoot

* **什么是springboot，为什么要用springboot**

  `Spring Boot`是一款集成框架。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。

  拥有超多集成依赖，不需要自己去导入或者查找，直接引入即可，非常方便。

  约定大于配置。

* **springboot的核心配置文件是什么，有哪几种类型，及区别**

  application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。
  bootstrap 配置文件有以下几个应用场景。
  使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
  一些固定的不能被覆盖的属性；
  一些加密/解密的场景；

  类型：

  properties和yml

  区别：

  1.bootstrap.yml（bootstrap.properties）先加载
  application.yml（application.properties）后加载

  2.bootstrap.yml 是系统级别的一些参数配置，这些参数一般是不变的。
  application.yml 一般用来定义单个应用级别的，如果搭配 spring-cloud-config 使用 application.yml 里面定义的文件可以实现动态替换。

  3.一旦bootStrap.yml 被加载，则内容不会被覆盖，即便后期加载的application.yml的内容标签与bootstrap的标签一致，application 也不会覆盖bootstrap, 而application.yml 里面的内容可以动态替换。

* **springboot实现热部署的方式**

  目前的 Java 虚拟机只能实现方法体的修改热部署，对于整个类的结构修改，仍然需要重启虚拟机，对类重新加载才能完成更新操作。

  深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。

## SpringCloud

* **什么是springcloud？核心组件有哪些？**

  为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。

  Eureka：
  服务启动的时候，服务上的Eureka客户端会把自身注册到Eureka服务端，并且可以通过Eureka服务端知道其他注册的服务
  Ribbon：
  服务间发起请求的时候，服务消费者方基于Ribbon服务做到负载均衡，从服务提供者存储的多台机器中选择一台，如果一个服务只在一台机器上面，那就用不到Ribbon选择机器了，如果有多台机器，那就需要使用Ribbon选择之后再去使用
  Feign：
  Feign使用的时候会集成Ribbon，Ribbon去Eureka服务端中找到服务提供者的所在的服务器信息，然后根据随机策略选择一个，拼接Url地址后发起请求
  Hystrix：
  发起的请求是通过Hystrix的线程池去访问服务，不同的服务通过不同的线程池，实现了不同的服务调度隔离，如果服务出现故障，通过服务熔断，避免服务雪崩的问题 ，并且通过服务降级，保证可以手动实现服务正常功能
  Zuul：
  类似Nginx。如果前端调用后台系统，统一走zull网关进入，通过zull网关转发请求给对应的服务

* **springcloud的断路器的作用**

  解决服务器雪崩问题

  Hystrix是隔离、熔断以及降级的一个框架，说白了就是Hystrix会搞很多小线程池然后让这些小线程池去请求服务，返回结果，Hystrix相当于是个中间过滤区，如果我们的积分服务挂了，那我们请求积分服务直接就返回了，不需要等待超时时间结束抛出异常，这就是所谓的熔断，但是也不能啥都不干就返回啊，不然我们之后手动加积分咋整啊，那我们每次调用积分服务就在数据库里记录一条消息，这就是所谓的降级，

* **Feign客户端的远程调用是怎么实现的?协议是什么？**

  Feign的一个机制就是使用了动态代理：

  - 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理
  - 接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心
  - Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址
  - 最后针对这个地址，发起请求、解析响应。（http协议）

## Dubbo

* **springcloud和dubbo如何选择，什么场景下使用springcloud**

  Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

  dubbo的优势

  单一应用架构，当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架（ORM）是关键。
  垂直应用架构，当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架（MVC）是关键。
  分布式服务架构，当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架（RPC）是关键。
  流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心（SOA）是关键。

  、dubbo
   协议，是默认的基于TCP 

  （一共9种协议，

  1、dubbo 协议 (默认)
  2、rmi 协议
  3、hessian 协议
  4、http 协议
  5、webservice 协议
  6、thrift 协议
  7、memcached 协议
  8、redis 协议
  9、rest ( 就是 RestFull)） 

  传输协议的长连接，NIO
   异步通信，适合于小数据量高并发的场景以及服务消费者机器数远大于服务提供者机器数的情况。

   ，不适合大文件，视频的传输

   连接个数：单连接

   连接方式：长连接

   传输协议：TCP

   传输方式：NIO
   异步传输

   序列化：Hessian
   二进制序列化

   适用范围：传入传出参数数据包较小（建议小于100K
   ），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo
   协议传输大文件或超大字符串。

   适用场景：常规远程服务方法调用Http
   协议

   采用Spring
   的HttpInvoker
   实现

   基于http
   表单的远程调用协议。

    

   连接个数：多连接

   连接方式：短连接

   传输协议：HTTP

   传输方式：同步传输

   序列化：表单序列化（JSON
   ）

   适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL
   传入参数，暂不支持传文件。

   适用场景：需同时给应用程序和浏览器JS
   使用的服务。

  SpringCloud是一系列框架的有序集合。它基于SpringBoot的便利性融合了一整套实现微服务的框架并提供了服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等组件。

  1：约定优于配置

  2：开箱即用、快速启动

  3：适用于各种环境

  4：轻量级的组件

  5：组件支持丰富，功能齐全

  整体比较

  1、dubbo由于是二进制的传输，占用带宽会更少

  2、springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大

  3、dubbo的开发难度较大，原因是dubbo的jar包依赖问题很多大型工程无法解决

  4、springcloud的接口协议约定比较自由且松散，需要有强有力的行政措施来限制接口无序升级

  5、dubbo的注册中心可以选择zk,redis等，springcloud的注册中心用eureka或者Consul

  **如何选择？**

  [参考](https://blog.csdn.net/qq_17231297/article/details/106184746)

  ​	1.开发难度：Dubbo开发难度大，原因是 Dubbo 的 jar 包依赖问题很多大型工程无法解决

  ​	2.公司发展：我不会选择很久没人维护的 Dubbo，重启之后也未必是原班人马。

  ​	3.招聘难度：招 Spring Cloud 的程序员会更好招，因为更新更炫。

  ​	4.系统结构简易程度：Spring Cloud的系统结构更简单，“注册+springmvc=springcloud”，而 Dubbo 各种复杂的 URL、protocol、register、invocation、dubbofilter、dubboSPI，dubbo序列化……炫技的成分更多一些。

  ​	5.性能：Dubbo 的网络消耗小于 Spring Cloud，但是在国内95%的公司内，网络消耗不是什么太大问题。如果真的成了问题，通过压缩、二进制、高速缓存、分段降级等方法，很容易解。

  ​	6.后续改进：Dubbo 的改进是通过 dubbofilter，很多东西没有，需要自己继承，如监控、日志、限流、追踪。Spring Cloud 自己带了很多监控、限流措施，但是功能可能和欧美习惯相同，国内需要进行适当改造，但更简单，就是 ServletFilter 而已，但是总归比 Dubbo 多一些东西是好的。

* **rpc框架都有哪些**

  **RPC**是远程过程调用的简称：

  ​	springcloud：具体是当中的Feign组件

  ​	dubbo：
  
  ​	其他：

## Mybatis

* **#{}和${}区别**

  a、#{}是预编译处理，${}是字符串替换。

  b、Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；
  c、Mybatis 在处理${}时，就是把${}替换成变量的值。
  d、使用#{}可以有效的防止 SQL 注入，提高系统安全性。

* **mybatis的执行过程**
  1.加载 conf.xml xxxMapper.xml，封装到Configuration，再封装到DefaultSqlSessionFactory，最终返回SqlSessionFactory。
  2.通过SqlSessionFactory拿到SqlSession，实际拿到的是DefaultSqlSession（其中包含Configuration，Executor执行器）
  3.执行器根据入参(默认是SimpleExecutor,共有3种类型)执行 MappedStatement（底层是<select>等标签），并且接受返回值。
  4.通过SqlSession获取动态代理接口，（包含SqlSession，动态代理接口对象，methodCache(存放查询缓存，底层是ConCurrentHashMap)）


* **mybatis中有几种分页方式**

  **逻辑分页：** 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。

  **物理分页：** 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。

* **MyBatis 逻辑分页和物理分页的区别是什么？**

  逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。
  物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。

* **RowBounds是一次性查询全部结果吗？为什么？**

  RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据。因为 MyBatis 是对 JDBC 的封装，在 JDBC 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在执行 next() 的时候，去查询更多的数据。 就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，要取 4 次才能把钱取完。对于 JDBC 来说也是一样，这样做的好处是可以有效的防止内存溢出。

* **mybatis是否支持延迟加载？延迟加载的原理**

  MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。

  延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。

* **说一下mybatis的一级缓存和二级缓存**

  一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。
  二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。
  开启二级缓存数据查询流程：二级缓存 -> 一级缓存 -> 数据库。

  二级缓存也可以使用第三方的缓存，比如，使用 Ehcache 作为二级缓存。

  缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

  **笔记**：

  二级（装饰者模式）：通过序列化的方式的。namespace级别的：注意，每次update会清空缓存（二级和一级），commit，才会填充缓存。

  一级：session级别，每次commit，update会清空

  总结：Mybatis在多表查询时，极大可能会出现脏数据。在分布式环境下，由于默认的Mybatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将Mybatis的Cache接口实现，有一定的开发成本，不如直接用Redis，Memcache实现业务上的缓存就好了。

  Mybatis的缓存机制设计的不是很完善，在使用上容易引起脏数据问题，个人建议不要使用Mybatis缓存，在业务层面上使用其他机制实现需要的缓存功能，让Mybatis老老实实做它的ORM框架就好了哈哈。

* **mybatis和hibernate的区别**

  灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。
  可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。
  学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。
  二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。

* **mybatis有哪些执行器（Executor发音 [ɪɡˈzekjətə(r)] ）**

  1、SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

  2、ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。

  3、BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 

  作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。

  默认是SimplExcutor，需要配置在创建SqlSession对象的时候指定执行器的类型即可。

  Mybatis中如何指定使用哪一种Executor执行器？

  答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。

* **MyBatis 有哪些拦截器？如何实现拦截功能？**

  答：MyBatis 提供的连接器有以下 4 种。

  Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作。
  StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存。
  ParameterHandler：拦截参数的处理。
  ResultSetHandler：拦截结果集的处理。

* **mybatis分页插件的实现原理**

  首先，在MyBatis内部定义了一个拦截器接口

  所有的插件都要实现该接口，来，我们看看这个接口的定义

  ```text
  public interface Interceptor {
  
    Object intercept(Invocation invocation) throws Throwable;
  
    Object plugin(Object target);
  
    void setProperties(Properties properties);
  
  }
  ```

  那么其中一个关键的方法就是intercept，从而实现拦截

  分页插件的原理就是使用MyBatis提供的插件接口，实现自定义插件，在插件的拦截方法内，拦截待执行的SQL，然后根据设置的dialect（方言），和设置的分页参数，重写SQL ，生成带有分页语句的SQL，执行重写后的SQL，从而实现分页

  所以原理还是基于拦截器,代理模式。

  将此拦截器添加到拦截器链中。

  至此我们发现PageHelper分页的实现原来是在我们执行SQL语句之前动态的将SQL语句拼接了分页的语句，从而实现了从数据库中分页获取的过程。

* **mybatis如何编写一个自定义插件**

  1、新建类实现 Interceptor 接口，并指定想要拦截的方法签名

  ```java
  /**
  
   * MyBatis 插件
     */
     @Intercepts({@Signature(type = Executor.class, method = "query", args = {MappedStatement.class, 						 Object.class, RowBounds.class, ResultHandler.class})})
     public class ExamplePlugin implements Interceptor {
  
     @Override
     public Object intercept(Invocation invocation) throws Throwable {
         for (Object arg : invocation.getArgs()) {
             System.out.println("参数：" + arg);
         }
         System.out.println("方法：" + invocation.getMethod());
         System.out.println("目标对象：" + invocation.getTarget());
         Object result = invocation.proceed();
  
         //只获取第一个数据
         if (result instanceof List){
             System.out.println("原集合数据：" + result);
             System.out.println("只获取第一个对象");
             List list = (List)result;
             return Arrays.asList(list.get(0));
         }
         return result;
  
     }
     }
  ```

  


  2、MyBatis 配置文件中添加该插件

  <plugins>
      <plugin interceptor="constxiong.plugin.ExamplePlugin">
      </plugin>
  </plugins>

  ```java
  //测试代码
  
  System.out.println("------userMapper.deleteUsers()------");
  //删除 user
  userMapper.deleteUsers();
  
  System.out.println("------userMapper.insertUser()------");
  //插入 user
  for (int i = 1; i <= 5; i++) {
      userMapper.insertUser(new User(i, "ConstXiong" + i));
  }
  
  System.out.println("------userMapper.selectUsers()------");
  //查询所有 user
  List<User> users = userMapper.selectUsers();
  System.out.println(users);
  
  
  //打印结果
  
  ------userMapper.deleteUsers()------
  ------userMapper.insertUser()------
  ------userMapper.selectUsers()------
  参数：org.apache.ibatis.mapping.MappedStatement@58c1c010
  参数：null
  参数：org.apache.ibatis.session.RowBounds@b7f23d9
  参数：null
  方法：public abstract java.util.List org.apache.ibatis.executor.Executor.query(org.apache.ibatis.mapping.MappedStatement,java.lang.Object,org.apache.ibatis.session.RowBounds,org.apache.ibatis.session.ResultHandler) throws java.sql.SQLException
  目标对象：org.apache.ibatis.executor.CachingExecutor@61d47554
  原集合数据：[User{id=1, name='ConstXiong1', mc='null'}, User{id=2, name='ConstXiong2', mc='null'}, User{id=3, name='ConstXiong3', mc='null'}, User{id=4, name='ConstXiong4', mc='null'}, User{id=5, name='ConstXiong5', mc='null'}]
  只获取第一个对象
  [User{id=1, name='ConstXiong1', mc='null'}]
  
  
  ```

  

## 多线程

* **并行和并发的区别**

  并行：多个处理器或者多核处理器同时执行多个任务。

  ​	真正意义的同时进行。

  并发：一个核心的处理器，执行多个任务。多个线程抢占cpu，在同一时刻只能有一条指令执行

* **线程和进程**

  进程：进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用。进程是资源分配的最小单位。

  线程：线程是CPU调度的最小单位

  \2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

  \3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信

  号等)，某进程内的线程在其他进程不可见；

  \4. 调度和切换：线程上下文切换比进程上下文切换要快得多

* **守护线程是什么**

  java里线程分2种，
  1、守护线程，比如垃圾回收线程，就是最典型的守护线程。因为当所有非守护线程结束时，没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了，程序也就终止了，同时会“杀死”所有守护线程。 典型如垃圾回收线程。

  2、用户线程，就是应用程序里的自定义线程。只要有任何非守护线程还在运行，程序就不会终止。

* **创建线程有哪几种方式**

  一、继承Thread类创建线程类

  （1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。

  （2）创建Thread子类的实例，即创建了线程对象。

  （3）调用线程对象的start()方法来启动该线程。

  二、通过Runnable接口创建线程类 

  （1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。

  （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。

  （3）调用线程对象的start()方法来启动该线程。

  三、通过Callable和Future创建线程

  （1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。

  （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。

  （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。

  （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

  ```java
  public class CallableThreadTest implements Callable<Integer> {
  
      public static void main(String[] args) {
          CallableThreadTest ctt = new CallableThreadTest();
          FutureTask<Integer> ft = new FutureTask<>(ctt);
          for (int i = 0; i < 100; i++) {
              System.out.println(Thread.currentThread().getName() + " 的循环变量i的值" + i);
              if (i == 20) {
                  new Thread(ft, "有返回值的线程").start();
              }
          }
          try {
              System.out.println("子线程的返回值：" + ft.get());
          } catch (InterruptedException e) {
              e.printStackTrace();
          } catch (ExecutionException e) {
              e.printStackTrace();
          }
  
      }
      @Override
      public Integer call() throws Exception {
          int i = 0;
          for (; i < 100; i++) {
              System.out.println(Thread.currentThread().getName() + " " + i);
          }
          return i;
      }
  
  }
  ```

  **三种方式对比：**

  采用实现Runnable、Callable接口的方式创见多线程时，优势是：

  线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

  在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

  劣势是：

  编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

  使用继承Thread类的方式创建多线程时优势是：

  编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

  劣势是：

  线程类已经继承了Thread类，所以不能再继承其他父类。

* **线程有哪些状态/线程的生命周期，什么时候会出现进程僵死**
  大致5种状态

  ![](https://img-blog.csdnimg.cn/20190527224156530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3E2NjkyMzk3OTk=,size_16,color_FFFFFF,t_70)

  \1. **新建(NEW)**：新创建了一个线程对象。

  \2. **可运行(RUNNABLE)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
  

\3. **运行(RUNNING)**：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
  \4. **阻塞(BLOCKED)**：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

  > (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
  > (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

  \5. **死亡(DEAD)**：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

  另外：

   一个线程会因为以下原因而放弃CPU：

  1. 时间片用完了，java虚拟机让当前线程暂时放弃CPU,转到就绪状态,使其它线程获得运行机会。
  2. 当前线程因为某些原因而进入阻塞状态
  3. 线程结束运行

  进程的停止，当一个进程中所有的前台线程停止后，该进程结束。

  如果希望明确地让一个线程给另外一个线程运行的机会，可以采取以下办法。
  1. 调整各个线程的优先级
  2. 让处于运行状态的线程调用Thread.sleep()方法
  3. 让处于运行状态的线程调用Thread.yield()方法
  4. 让处于运行状态的线程调用另一个线程的join()方法

* **什么是线程安全，如何实现线程安全**

  线程安全：

  多线程访问的时候，保证原子性，可见性，有序性是安全的。或者说多线程访问一个对象的时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

  如何实现线程安全：

  ​	1.阻塞同步。

  如Synchronized

  ​	2.非阻塞同步。

  如CAS：它有三个操作数：内存位置，旧的预期值，新值，在执行CAS操作时，当且仅当内存地址的值符合旧的预期值的时候，才会用新值来更新内存地址的值，否则就不执行更新。

  ​	3.不同步方案。

  线程本地存储：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题。

  经常使用的就是ThreadLocal类

  ThreadLocal类 最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等。

* **sleep()和wait()的区别**

  sleep是Thread的方法，wait是Object的方法

  区别一，sleep（）线程控制自身流程。wait（）用来线程间通信，使拥有该对象锁的线程等待直到指定时间或notify（）。

  区别二，sleep（）方法的线程不会释放对象锁。wait（）方法的线程会释放对象锁。

  wait可以代替sleep吗？
  答案不可以，如果直接调用wait会报出java.lang.IllegalMonitorStateException异常，原因是还没有得到对象锁，所以无法释放锁。

* **notity()和notifyAll()的区别**

  - notifyAll使所有**原来在该对象上等待**被notify的**所有线程统统退出wait的状态**，变成**等待该对象上的锁**，**一旦该对象被解锁**，他们就会去**竞争**。

  - notify则文明得多，它只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。

    注意：必须在synchronized中 才能使用 wait(),notity(), wait（）会释放锁，如果唤醒后，需要重新获得锁才能继续执行

* **线程的run()和start()的区别**

  一个是线程执行的方法；

  一个是启动线程，使其到达可运行的状态；

* **为什么需要线程池**

  - **它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗**。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。

  - **提高响应速度。** 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。

  - **重复利用。** 线程用完，再放回池子，可以达到重复利用的效果，节省资源。

    总结：

    1. 线程复用
    2. 控制最大并发数
    3. 管理线程

* **创建线程池有哪几种方式**

  1.`Executors`是一个线程相关的工具类。

  2.ThreadPoolExecutor

* **线程池的几个重要参数，如何合理配置线程池的大小**

  几个核心参数的作用：

  - **corePoolSize：** 线程池核心线程数最大值

    CPU核数 = Runtime.getRuntime().availableProcessors()

    分析下线程池处理的程序是CPU密集型还是IO密集型

    CPU密集型：corePoolSize = CPU核数 + 1 

    ​	cpu占用率高，尽量少开线程。

    IO密集型：corePoolSize = CPU核数 * 2
    	因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，增加cpu的利用率。

  - **maximumPoolSize：** 线程池最大线程数大小

  - **keepAliveTime：** 线程池中非核心线程空闲的存活时间大小

  - **unit：** 线程空闲存活时间单位

  - **workQueue：** 存放任务的阻塞队列

  - **threadFactory：** 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。

  - **handler：** 线城池的饱和策略事件，主要有四种类型。

    如何设置参数
    默认值：

    corePoolSize = 1

    maxPoolSize = Integer.MAX_VALUE

    queueCapacity = Integer.MAX_VALUE

    keepAliveTime = 60s

    allowCoreThreadTimeout = false

    rejectedExecutionHandler = AbortPolicy()

    **如何来设置呢？**

    需要根据几个值来决定

    tasks ：每秒的任务数，假设为500~1000

    taskcost：每个任务花费时间，假设为0.1s

    responsetime：系统允许容忍的最大响应时间，假设为1s

    做几个计算

    corePoolSize = 每秒需要多少个线程处理？

    threadcount = tasks/(1/taskcost) = tasks*taskcout = (500 ~ 1000)*0.1 = 50~100 个线程。

    corePoolSize设置应该大于50。

    根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可。

    queueCapacity = (coreSizePool/taskcost)*responsetime

    计算可得 queueCapacity = 80/0.1*1 = 800。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行。

    切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。

    maxPoolSize 最大线程数在生产环境上我们往往设置成corePoolSize一样，这样可以减少在处理过程中创建线程的开销。

    rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理。

    keepAliveTime和allowCoreThreadTimeout采用默认通常能满足。

    以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件和优化代码，降低taskcost来处理。
    队列的选择：主要有3种类型的BlockingQueue可供选择：

    `无界队列`，可能导致oom，导致cpu和内存飙升服务器挂掉。例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。

    `有界队列`当使用有限的 maximumPoolSizes 时，有界队列有助于防止资源耗尽，但是可能较难调整和控制。常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。

    使用有界队列时队列大小需和线程池大小互相配合，线程池较小有界队列较大时可减少内存消耗，降低cpu使用率和上下文切换，但是可能会限制系统吞吐量。

    `同步移交`如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。

* **线程池的实现原理和线程的调度过程**

  1. 线程复用

  2. 控制最大并发数

  3. 管理线程

     调度过程：

     - 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。
     - 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。
     - 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。
     - 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。

* **线程池有哪些状态**

  **RUNNING**

  - 该状态的线程池会接收新任务，并处理阻塞队列中的任务;
  - 调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;
  - 调用线程池的shutdownNow()方法，可以切换到STOP状态;

  **SHUTDOWN**

  - 该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；
  - 队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;

  **STOP**

  - 该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；
  - 线程池中执行的任务为空,进入TIDYING状态;

  **TIDYING**

  - 该状态表明所有的任务已经运行终止，记录的任务数量为0。
  - terminated()执行完毕，进入TERMINATED状态

  **TERMINATED**

  - 该状态表示线程池彻底终止

* **线程池的submit()和execute()的区别**

  execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。

  submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果

* **在java程序中怎么保证多线程的运行安全**

  1. 使用synchronied关键字，可以用于代码块，方法（静态方法，同步锁是当前字节码对象；实例方法，同步锁是实例对象）
  2. 使用volatile 关键字，防止指令重排，被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量
  3. lock锁机制

  手动锁示例代码：

  ```java
  Lock lock = new ReentrantLock();
  lock. lock();
  try {
      System. out. println("获得锁");
  } catch (Exception e) {
      // TODO: handle exception
  } finally {
      System. out. println("释放锁");
      lock. unlock();
  }
  ```

  4. 使用线程安全的类，比如Vector、HashTable、StringBuffer，juc下的类

* **多线程锁的升级原理**（jdk6以后默认开启偏向锁）

  synchronized用的锁存在Java对象头里，Java对象头里的Mark Word默认存储对象的HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。

  锁的级别从低到高：不可降级

  无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

  锁分级别原因：

  没有优化以前，synchronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll 来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 synchronized 关键字进行了优化，把锁分为 无锁、偏向锁、轻量级锁、重量级锁 状态。

  1、无锁：
  没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。

  2、偏向锁：
  偏向锁的核心思想就是锁会偏向第一个获取它的线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。在接下来的执行过程中该锁没有其他的线程获取，则持有偏向锁的线程永远不需要再进行同步。

  当一个线程访问同步块并获取锁的时候，会在对象头和栈帧中的锁记录里存储偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需要检查当前 Mark Word 中存储的线程是否为当前线程，如果是，则表示已经获得对象锁；否则，需要测试 Mark Word 中偏向锁的标志是否为1，如果没有则使用 CAS 操作竞争锁，如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。

  偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁；如果线程处于活动状态，升级为轻量级锁的状态。

  3、轻量级锁：
  轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。

  当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。

  4、重量级锁：
  指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。

  重量级锁将程序运行交出控制权，将线程挂起，由操作系统来负责线程间的调度，负责线程的阻塞和执行。这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，消耗大量的系统资源，导致性能低下。

  重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

  锁状态对比

  ![](https://img-blog.csdnimg.cn/20200620154814777.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0NjQ2Mg==,size_16,color_FFFFFF,t_70#pic_center)

  synchronized优化-锁消除:

  　　消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。

  https://blog.csdn.net/weixin_38481963/article/details/88384493

  [一个好的理解就是上面这个链接](https://blog.csdn.net/weixin_38481963/article/details/88384493)

* **什么是死锁，该怎么防止**

  **定义**：线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。

  当然死锁的产生是必须要满足一些特定条件的：
  1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放
  2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
  3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
  4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。
  **如何防止**：

  加锁顺序：

  ​	当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。

  如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

  加锁时限

  ​	另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。

  死锁检测

  ​	死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

  每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。

  当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

  当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。那么当检测出死锁时，这些线程该做些什么呢？

  一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。

  一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。

* **ThreadLocal是什么，原理，有哪些使用场景**

  定义：ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，而且线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会影响程序执行性能。

  但是要注意，虽然ThreadLocal能够解决上面说的问题，但是由于每个线程都创建副本，所以要考虑它对资源的消耗，比如内存的占用会比不使用ThreadLocal要大。

  原理：

  get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，

  set()用来设置当前线程中变量的副本，

  remove()用来移除当前线程中变量的副本，

  initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。

  首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。

  初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。

  ​    然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。

  使用场景：

  数据库连接

  ```java
  package OSChina.Thread;
  
  import java.sql.Connection;
  import java.sql.DriverManager;
  
  public class ThreadDao {
      private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>();
      public Connection initialValue(){
          return DriverManager.getConnection(DB_URL);
      }
      
      public static Connection getConnection(){
          return connectionHolder.get();
      }
  }
  ```

  session管理：

  ```java
  package OSChina.Thread;
  
  import javax.websocket.Session;
  
  public class ThreadDao {
      private static final ThreadLocal threadSession = new ThreadLocal();
      public static Session getSession() throws Exception{
          Session session = (Session)threadSession.get();
          if(session==null){
              session = getSessionFactory().openSession();
              threadSession.set(session);
          }
          return session;
      }
  }
  ```

* **ThreadLocal什么时候会出现OOM，为什么**

  ThreadLocal里面使用了一个存在**弱引用**的map,当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露. 最好的做法是将调用threadlocal的remove方法.

  在threadlocal的生命周期中,都存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用.


  每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap。 Map中的key为一个Threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收. 但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.
  　　

  所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。

  PS.Java为了最小化减少内存泄露的可能性和影响，在ThreadLocal的get,set的时候都会清除线程Map里所有key为null的value。所以最怕的情况就是，threadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，这个线程结束，线程放回线程池中不销毁，这个线程一直不被使用，或者分配使用了又不再调用get,set方法，那么这个期间就会发生真正的内存泄露。

  划重点-总结一下：

  ThreadLocal是什么？
  每个线程在对内存中开辟的一块工作内存，同时把线程的共享数据拷贝了一份放进去，相当于做的本地副本，不会像synchronized一样每次修改都要同步到主内存中
  ThreadLocal有什么用？
  工作线程的数据交互主要是本地数据和主内存数据的交互，当数据存储在本地内存中，可以大大提高读取效率，避免了线程阻塞造成的cpu的吞吐下降；
  在多线程中每个线程中都要维护sesion，可以提高对独有资源的工作效率；
  发生内存泄露原因？
  synchornized是保证了主内存数据的一致，是时间换空间：通过阻塞一个共享变量，共享一小块内存空间；
  threadLocal是通过建立线程的副本数据，空间换时间
  ThreadLocalMap的Key为弱引用，当threadlocal对象被回收（value在ThreadLocalMap调用get、set、remove的时候就会被清除），这时将key设置为null的entry。但是threadlocal一直不会被回收，导致内存的泄露
  如何避免呢？
  其实在调用threalocalMap的get/set方法时，会对key=null的entry（threadlocal对象=null）进行回收，也可以在调用结束时调用remove方法进行释放。

  **下面是另外的博客的不错的解释：可以对比理解。**

  在ThreadLocal的生命周期中，都存在这些引用。看下图: **实线代表强引用，虚线代表弱引用。**

  ![0?wx_fmt=png](https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdasicN3xUZAG3e71xejQk0F5gXenp950M8DDaOSibicOYVKzpHvudd3u4SzMQD0gr2PQsCicUjt10bvuQ/0?wx_fmt=png)2、ThreadLocal的实现是这样的：每个Thread 维护一个 `ThreadLocalMap` 映射表，这个映射表的 key 是 `ThreadLocal`实例本身，value 是真正需要存储的 Object。

  3、也就是说 `ThreadLocal` 本身并不存储值，它只是作为一个 key 来让线程从 `ThreadLocalMap` 获取 value。值得注意的是图中的虚线，表示 `ThreadLocalMap` 是使用 `ThreadLocal` 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。

  4、ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：**`Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value`**永远无法回收，造成内存泄漏。

  5、总的来说就是，ThreadLocal里面使用了一个存在弱引用的map, map的类型是`ThreadLocal.ThreadLocalMap.` Map中的key为一个threadlocal实例。这个Map的确使用了**弱引用**，不过弱引用只是针对key。每个key都弱引用指向threadlocal。 当把threadlocal实例置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。

  但是，我们的value却不能回收，而这块value永远不会被访问到了，所以存在着内存泄露。因为存在一条从`current thread`连接过来的强引用。只有当前thread结束以后，`current thread`就不会存在栈中，强引用断开，Current Thread、Map value将全部被GC回收。最好的做法是将调用threadlocal的remove方法，这也是等会后边要说的。

  6、其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：**在ThreadLocal的****`get(),set(),remove()`的时候都会清除线程ThreadLocalMap里所有key为null的value**。这一点在上一节中也讲到过！

  7、但是这些被动的预防措施并不能保证不会内存泄漏：

  1. `（1）使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏。`
  2. `（2）分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏，因为这块内存一直存在。`

  三、为什么使用弱引用，OOM是否是弱引用的锅？

  1、从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：**为什么使用弱引用而不是强引用？**

  我们先来看看官方文档的说法：

  ![0?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdasicN3xUZAG3e71xejQk0F52cAG5zjKkuHQRBHg6IJFTrglJn7rWOibWTquPaWd8ajFleSIzO2cicsg/0?wx_fmt=png)

  下面我们分两种情况讨论：

  **（1）key 使用强引用**：引用的`ThreadLocal`的对象被回收了，但是`ThreadLocalMap`还持有`ThreadLocal`的强引用，如果没有手动删除，`ThreadLocal`不会被回收，导致Entry内存泄漏。

  **（2）key 使用弱引用**：引用的ThreadLocal的对象被回收了，由于`ThreadLocalMap`持有`ThreadLocal`的弱引用，即使没有手动删除，`ThreadLocal`也会被回收。`value`在下一次`ThreadLocalMap`调用`set、get、remove`的时候会被清除。

  比较两种情况，我们可以发现：由于`ThreadLocalMap`的生命周期跟Thread一样长，如果都没有手动删除对应key，**都会**导致内存泄漏，但是**使用弱引用可以多一层保障**：**弱引用****`ThreadLocal`不会内存泄漏，对应的value在下一次`ThreadLocalMap`调用`set、get、remove`的时候会被清除。**

  因此，ThreadLocal内存泄漏的根源是：**由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。**

* **volatile是什么，原理，有哪些使用场景**

  被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。

  原理：在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。

  主要有这两个方面的影响：

  1. 将当前处理器缓存行的数据写回系统内存；

  2. 通过MESI缓存一致性协议，总线嗅探机制使这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效

     当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

     这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。

     volatile保证了可见性，有序性（被volatile修饰的变量，严格按照代码编写顺序执行，禁止指令重排序）。但无法保证原子性。

     使用场景：https://www.cnblogs.com/ouyxy/p/7242563.html

* **说下synchronized底层实现原理**

  jvm中，对象在内存中的布局

  三块区域：对象头、实例数据和对齐填充。

  原理：通过对对象的内置Monitor锁的获取和释放来实现（每个对象都有自己的Monitor监视器锁（对象））。一个线程的执行，首先读取主内存的共享变量需要过去锁，执行Monitor方法 enter方法，不成功的话，进入等待队列，成功的话，同步object对象的属性（这里是有用户态到内核态的切换，费性能）。执行完JMM8大原子操作中的write后，释放锁执行exit方法。唤醒当前锁对象的等待队列。（两个monitorexit是因为一个是正常出口，一个是异常出口。）

  ​	jdk1.6以后：Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。

  Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。

  这里要注意：

  - synchronized是可重入的，所以不会自己把，自己锁死

    原理：重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。**底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。

  - synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将被阻塞。

* **synchronized锁粒度，原子性和可见性**

  锁粒度：

  粒度为 4 种：
  修饰一个代码块： 一个线程正在访问一个对象中的 synchronized(this 或 其他对象) 同步代码块时，其他试图访问该对象（要是同一个对象）的线程将被阻塞。

  修饰一个普通方法： 在方法的前面加 synchronized，public synchronized void method()，此方法等于修饰整个方法代码块。

  修饰一个静态的方法：public synchronized static void method()，静态方法是属于类的，同样的，synchronized 修饰的静态方法锁定的是这个类的所有对象。

  修饰一个类：synchronized(ClassName.class)，synchronized 作用于一个类时，是给这个类加锁，该类的所有对象都将加同一把锁。

  - 原子性：synchronized保证语句块内操作是原子的
  - 可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）
  - 有序性：synchronized保证有序性（通过“一个变量在同一时刻只允许一条线程对其进行lock操作”）

* **sychronized和volatile区别**

  volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
  volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
  volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
  volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
  volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化（指令重排序）

* **sychronized和Lock区别**

  1、lock是一个接口，而synchronized是java的一个关键字。

  2、synchronized在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常时，不会主动释放占有的锁，必须手动来释放锁，可能引起死锁的发生，必须在finally{}中释放。

  3、锁的获取：前者阻塞式，后者分情况。

  4、synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。

  而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。

  现代的CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作非阻塞算法，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。

* **sychronized和ReentrantLock区别是什么**

  synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。

  1.某个线程在等待一个锁的控制权的这段时间需要中断
  2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程
  3.具有公平锁功能，每个到来的线程都将排队等候

  下面细细道来……

  先说第一种情况，ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制：可中断/可不中断
  第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；
  第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。

  区别：

  \1. ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁
  \2. ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的
  不可用性提供了更高的灵活性
  \3. ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的
  \4. ReentrantLock 可以实现公平锁
  \5. ReentrantLock 通过 Condition 可以绑定多个条件
  \6. 底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻
  塞，采用的是乐观并发策略
  \7. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言
  实现。
  \8. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
  而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，
  因此使用 Lock 时需要在 finally 块中释放锁。
  \9. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，
  等待的线程会一直等待下去，不能够响应中断。
  \10. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
  \11. Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等

   * 1 原始结构

   * synchronized是关键字，属于jvm层（monitorenter：底层通过monitor来完成的，wait/notify方法也依赖monitor，只有在同步块或者同步方法中才可以调用wait/notify

   * 。monitorexit）

   * ReentrantLock 是具体类，是api层面的锁

   * 2使用方法

   * synchronized不需要用户手动释放锁，当synchronized方法运行完之后系统自动让线程释放锁；

   * ReentrantLock需要用户手动释放锁，如果没有释放，出现死锁现象；需要lcok（）unlock（）方法配合try/finally语法块来释放；

   * 3 等待是否中断

   * synchronized不可中断，除非抛出异常或者运行完成

   * ReentrantLock可中断：1设置超时方法时间truLock（）；2 lcokInterruptibly（）放代码块中，调用interrupt可中断

   * 4 加锁是否公平

   * synchronized非公平锁；

   * ReentrantLock非公平锁/公平锁

   * 5 锁绑定多个条件

   * synchronized没有；

   * ReentrantLock用来实现分组唤醒线程组，可精确唤醒，synchronized是随机唤醒一个或者唤醒全部

    另外的：由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：

            1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。
        
            2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。

    公平锁、非公平锁的创建方式：

    //创建一个非公平锁，默认是非公平锁
    Lock lock = new ReentrantLock();
    Lock lock = new ReentrantLock(false);

    //创建一个公平锁，构造传参true
    Lock lock = new ReentrantLock(true);
            3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

* **说一下atomic的原理**

  定义：一种轻量级的数据同步的选择。

  原理：unsafe是java提供的获得对对象内存地址访问的类，注释已经清楚的写出了，它的作用就是在更新操作时提供“比较并替换”的作用。实际上就是AtomicInteger中的一个工具。

  valueOffset是用来记录value本身在内存的编译地址的，这个记录，也主要是为了在更新操作在内存中找到value的位置，方便比较。

   value是用来存储整数的时间变量，这里被声明为volatile。volatile只能保证这个变量的可见性。不能保证他的原子性。

   可以看看getAndIncrement这个类似i++的函数，可以发现，是调用了UnSafe中的getAndAddInt。

  如何保证原子性：自旋 + CAS（乐观锁）。在这个过程中，通过compareAndSwapInt比较更新value值，如果更新失败，重新获取旧值，然后更新。


  优缺点：
        CAS相对于其他锁，不会进行内核态操作，有着一些性能的提升。但同时引入自旋，当锁竞争较大的时候，自旋次数会增多。cpu资源会消耗很高。

        换句话说，CAS+自旋适合使用在低并发有同步数据的应用场景。

   





  Java 8做出的改进和努力
        在Java 8中引入了4个新的计数器类型，LongAdder、LongAccumulator、DoubleAdder、DoubleAccumulator。他们都是继承于Striped64。

       在LongAdder 与AtomicLong有什么区别？
  Atomic*遇到的问题是，只能运用于低并发场景。因此LongAddr在这基础上引入了分段锁的概念。可以参考《JDK8系列之LongAdder解析》一起看看做了什么。

       大概就是当竞争不激烈的时候，所有线程都是通过CAS对同一个变量（Base）进行修改，当竞争激烈的时候，会将根据当前线程哈希到对于Cell上进行修改（多段锁）。
  可以看到大概实现原理是：通过CAS乐观锁保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。

* **知道哪些锁？公平锁和非公平锁区别？可重入锁是什么？**

  https://www.cnblogs.com/jyroy/p/11365935.html

  https://www.cnblogs.com/lxmyhappy/p/7380073.html

  - 公平锁/非公平锁

  - 可重入锁

  - 独享锁/共享锁

  - 互斥锁/读写锁

  - 乐观锁/悲观锁

  - 分段锁

  - 偏向锁/轻量级锁/重量级锁

  - 自旋锁

    ![](https://img-blog.csdnimg.cn/20181122101753671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F4aWFvYm9nZQ==,size_16,color_FFFFFF,t_70)

## 反射

* **什么是反射**

  反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。

  我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。

  Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。

* **什么是java序列化？什么情况下需要序列化**

  序列化：将 Java 对象转换成字节流的过程。

  反序列化：将字节流转换成 Java 对象的过程。

  当 Java 对象需要在网络上传输 或者 持久化存储到文件中时，就需要对 Java 对象进行序列化处理。

  序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。

  注意事项：

  某个类可以被序列化，则其子类也可以被序列化
  声明为 static 和 transient 的成员变量，不能被序列化。static 成员变量是描述类级别的属性，transient 表示临时数据
  反序列化读取序列化对象的顺序要保持一致

* **动态代理是什么？有哪些应用？**

  代理的使用情况：

  (1)设计模式中有一个设计原则是开闭原则，是说对修改关闭对扩展开放，我们在工作中有时会接手很多前人的代码，里面代码逻辑让人摸不着头脑(sometimes the code is really like shit)，这时就很难去下手修改代码，那么这时我们就可以通过代理对类进行增强。

  (2)我们在使用RPC框架的时候，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这个时候，就可用通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。

  (3)Spring的AOP机制就是采用动态代理的机制来实现切面编程。

  **静态代理和动态代理**

  我们根据加载被代理类的时机不同，将代理分为静态代理和动态代理。如果我们在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类这就是动态代理，比如RPC框架和Spring AOP机制。
  我们看到jdk的代理机制必须要求被代理类实现某个方法，这样在生成代理类的时候才能知道重新那些方法。这样一个没有实现任何接口的类就无法通过jdk的代理机制进行代理，当然解决方法是使用cglib的代理机制进行代理。

  

* **怎么实现动态代理**

  一种是**JDK**动态代理，

  一种是CGLIB字节码机制，当然还有Javassist或ASM库

  ```java
  //JDK动态代理，反射机制
  public class MyInvocationHandler implements InvocationHandler{
  	
  	private Object object;
  	
  	public MyInvocationHandler(Object object){
  		this.object = object;
  	}
   
  	@Override
  	public Object invoke(Object proxy, Method method, Object[] args)
  			throws Throwable {
  		// TODO Auto-generated method stub
  		System.out.println("MyInvocationHandler invoke begin");
  		System.out.println("proxy: "+ proxy.getClass().getName());
  		System.out.println("method: "+ method.getName());
  		for(Object o : args){
  			System.out.println("arg: "+ o);
  		}
  		//通过反射调用 被代理类的方法
  		method.invoke(object, args);
  		System.out.println("MyInvocationHandler invoke end");
  		return null;
  	}
  	
  	public static void main(String [] args){
  		//创建需要被代理的类
  		Student s = new Student();
  		//这一句是生成代理类的class文件，前提是你需要在工程根目录下创建com/sun/proxy目录，不然会报找不到路径的io异常
  		System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");
  		//获得加载被代理类的 类加载器
  		ClassLoader loader = Thread.currentThread().getContextClassLoader();
  		//指明被代理类实现的接口
  		Class<?>[] interfaces = s.getClass().getInterfaces();
  		// 创建被代理类的委托类,之后想要调用被代理类的方法时，都会委托给这个类的invoke(Object proxy, Method method, Object[] args)方法
  		MyInvocationHandler h = new MyInvocationHandler(s);
  		//生成代理类
  		Person proxy = (Person)Proxy.newProxyInstance(loader, interfaces, h);
  		//通过代理类调用 被代理类的方法
  		proxy.sayHello("yujie.wang", 20);
  		proxy.sayGoodBye(true, 100);
  		System.out.println("end");
  	}
  ```

  从上面的例子中可以看出，代理对象的生成是通过`Proxy.newProxyInstance()`来完成的

  ```
  public static Object newProxyInstance(ClassLoader loader,
                                            Class<?>[] interfaces,
                                            InvocationHandler h)
  ```

  `newProxyInstance()`方法主要以下三个参数

  - 类加载器(ClassLoader)用来加载动态代理类
  - 一个要实现接口的数组，从这点就可以看出，要想**使用JDK动态代理，必须要有接口类**
  - InvocactionHandler接口的一个实现

  **cglib**：本质上说，对于需要被代理的类，它只是动态生成一个子类以覆盖非final的方法，同时绑定钩子回调自定义的拦截器。

  添加CGLIB依赖

  ```
   <dependency>
        <groupId>cglib</groupId>
        <artifactId>cglib</artifactId>
        <version>3.2.4</version>
   /dependency>
  复制代码
  package com.pjmike.proxy;
  
  import net.sf.cglib.proxy.Enhancer;
  import net.sf.cglib.proxy.MethodInterceptor;
  import net.sf.cglib.proxy.MethodProxy;
  
  import java.lang.reflect.Method;
  
  /**
   * CGLIB动态代理实现
   *
   * @author pjmike
   * @create 2018-08-06 16:55
   */
  public class CglibProxy {
      public static void main(String[] args) {
          //Enhancer是CGLIB的核心工具类,是一个字节码增强器，它可以方便的对类进行扩展
          Enhancer enhancer = new Enhancer();
          enhancer.setSuperclass(PersonService.class);
          //设置回调所需的拦截器
          enhancer.setCallback(new MyMethodInterceptor());
          //通过enhancer.create()方法获取代理对象
          //对代理对象所有非final的方法调用都会转发给MethodInterceptor.intercept方法,
          //作用跟JDK动态代理的InvocationHandler类似
          PersonService personService = (PersonService) enhancer.create();
          System.out.println(personService.sayHello("pjmike"));
      }
  }
  
  class PersonService {
      public String sayHello(String name) {
          return "Hello, " + name;
      }
  }
  
  class MyMethodInterceptor implements MethodInterceptor {
  
      @Override
      public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
          return methodProxy.invokeSuper(obj, args);
      }
  }
  复制代码
  ```

  至于上面提到的javassist也是需要直接操作字节码，跟ASM类似，所以这两者使用门槛比较高，一般用于框架的底层实现。比如hibernate底层使用了javassist和cglib.

  **实际应用**

  ### 应用一: Spring AOP的动态代理实现

  Spring AOP的动态代理实现主要有两种方式，JDK动态代理和CGLIB字节码生成。

  默认情况下，如果Spring AOP发现目标对象后实现了相应的interface,则采用JDK动态代理机制为其生成代理对象。如果没有发现接口，则采用CGLIB的方式为目标对象生成动态的代理对象实例

  ### 应用二: RPC框架中的应用

  RPC即远程过程调用，它的实现中使用到了动态代理

## 对象拷贝

* **为什么要使用克隆**
* **如何实现克隆**
* **深拷贝和浅拷贝的区别**

## Java Web

* **cookie和session的区别及各自原理**
* **如果客户端禁止cookie能实现session还能用吗**
* **什么XSS攻击，怎么避免**
* **什么是CSRF（跨站请求伪造）攻击，怎么避免**
* **单点登录的原理，你们jwt（json web token）中包含哪些信息？**
* **项目中的搜索功能是怎么实现的？ES+kibana  ik分词**
* **elasticsearch的主从、字符串类型是哪个、nested类型是什么、聚合怎么写、查询某个id的语句、创建es的索引、时间类型怎么存的（我说了个utc...他说utc的话你的时间得+8，我蒙了）**
* **引入第三方登录时，怎么使得你自己的token和第三方的token关联起来？**
* **服务端如何防止表单重复提交**
* **打印日志的框架，错误日志怎么配置**
* **网络抖动，重复提交，怎么处理幂等性**

## 数据库MySql

* **如何避免sql注入**
* **数据库的三范式**
* **一张自增表里共有7条数据，删除了最后2条，重启mysql，有插入了一条数据，此时id是几**
* **如何获取当前数据库的版本**
* **说一下ACID是什么**
* **char和varchar的区别**
* **float和double的区别**
* **mysql的内、左、右连接的区别**
* **mysql的索引是怎么实现的**
* **怎么验证mysql的索引是否满足需求**
* **说一下数据库的事务隔离**
* **说一下mysql常用的引擎**
* **说一下mysql的行锁、表锁、共享锁、排他锁**
* **乐观锁和悲观锁，实现方式，业务场景**
* **向mysql中插入1000w条数据，怎么操作**

## Redis

* **是什么？有哪些使用场景**
* **有哪些功能，Redis的有哪些模式？**
* **redis为什么这么快？**
* **redis和memecache的区别**
* **redis为什么是单线程的**
* **redis采用多线程会有哪些问题**
* **什么是缓存穿透。。。如何解决**
* **redis支持的数据类型**
* **redis支持的java客户端有哪些**
* **jedis和redission有哪些区别**
* **怎么保证缓存和数据库数据的一致性**
* **redis的持久化策略**
* **redis怎么实现分布式锁，redis分布式锁操作的原子性，redis内部如何实现的**
* **redis分布式锁有什么缺陷**
* **redis如何做内存优化**
* **redis的淘汰策略有哪些**
* **redis的常见性能问题有哪些？该怎么解决**
* **redis主从原理**

## 分布式

### 分布式事务

* **谈谈对分布式事务的理解**
* **场景的解决方案有哪些**
* **什么是两阶段提交、三阶段提交**

### 其他

* **有没有写过分布式的业务，分布式存储？你觉得分布式的话会遇到什么问题呢？**

* 

## 消息中间件

### kafka

* **kafka可以脱离zk单独使用吗？为什么**
* **kafka有几种数据保留的策略**
* **kafka同时设置了7天和10G清除数据，到第五天的时候达到了10G，这个时候kafka如何处理**
* **什么情况下，会导致kafka运行变慢**
* **使用kafka集群需要注意什么**

### RabbitMQ

省略了rabbitmq

* **使用场景**
* **有哪些重要的角色**
* **有哪些重要的组件**
* **vhost的作用**
* **消息是怎么发送到的**
* **怎么保证消息的稳定性**
* **怎么避免消息丢失**
* **要保证消息持久化成功的条件有哪些**
* **持久化有什么缺点**
* **有几种广播类型**
* **怎么实现延迟消息队列**
* **集群有什么用**
* **集群搭建需要注意哪些问题**
* **节点的类型有哪些**
* **每个节点是其他节点的完整拷贝吗？为什么？**
* **集群中唯一一个磁盘节点崩溃了会发生什么情况**
* **对集群节点停止顺序有要求吗**
* **MQ怎么知道消息被指定的消费者消费？怎么使不同的生产者生产的消息被不同的消费者消费？**
* **mq中一条消息出现了异常，怎么处理**
* **mq1000个消息始终不被消费怎么处理（我说不处理...她笑了）**

### 其他问题

* **了解几种消息中间件产品？各产品有缺点介绍**
* **消息中间件如何保证消息的一致性和如何进行消息的重试机制**

## 设计模式

* **说一下熟悉的设计模式**
* **简单工厂和抽象工厂的区别**
* **代理模式和动态代理什么区别**

## 数据结构和算法

* **红黑的实现原理和场景**
* **给你两个二叉搜索树，如何使用线性的时间复杂度，将他们合并成一颗二叉搜索树**
* **给定一个二叉搜索树，编写一个函数kthSmallest来查找其中第k个最小的元素**
* **给定一个二叉树，找到该树中两个指定节点的最近公共祖先**
* **二叉树的序列号和反序列化**
* **如何找出一个单项链表的中间元素**
* **写一个函数，打印树的中序遍历**
* **用java写一个方法，判断一个树是否是二叉搜索树**
* **用java写一个方法，判断一个树是否是平衡树**
* **用java实现二分搜索算法**
* **用java实现插入排序**
* **用java实现冒泡排序**
* **实现从一个数组中移除重复元素**
* **如何找出最大和最小的数在一个数组中**
* **为什么char数组能比String更好的去存储password**
* **给你一个长度为n的数组，其中只有一个数字出现了奇数次，其他均出现偶数次，问，如何使用优秀的时空复杂度快速找到这个数字**
* **给你一个长度为n的数组，其中只有一个数字出现了大于等于n/2次，问，如何使用优秀的时空复杂度快速找到这个数字**
* **一个包含1-100数字的数组中，有一个数字丢失了，如何快速找出它**
