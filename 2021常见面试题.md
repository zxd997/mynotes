# 常见面试题

## Java基础

* **== 和 equals()区别**

  ==：对于基本数据类型比较的是值是否相等；

  ​		对于引用数据类型比较的是内存地址是否相同；

  equals(): 只有引用类型有意义；属于Object的方法，当中就是==比较，但是如String类重写了此方法，比较的是值

* **两个对象的hashCode()相同，则equals()也一定为true吗**

  两个对象equals返回true，那么hashcode一定相等；两个对象的hashcode相等，那么equals不一定为true。
  重写equals()方法，则hashCode()方法也必须重写，这样才能保证equals()方法返回true时，hashcode的值相等。

* **java是值传递还是引用传递**

  1.这个题目出的不严谨，但是很好(因为涉及了 Java 内存模型)
  2.就 Java 语言本身来说，只有值传递，没有引用传递。
  3.根据 值传递，引用传递的定义来说：
          Java 中的基本类型，属于值传递。
          Java 中的引用类型，属于引用传递。
          Java 中的 String 及包装类，属于特殊群体，作为形参时，由于每次赋值都相当于重新创建了对象，因此看起来像值传递，但是其特性已经破坏了，值传递、引用传递的定义。因此他们属于引用传递的定义，却表现为值传递。

* **final关键字**

  1、用来修饰一个引用
   如果引用为基本数据类型，则该引用为常量，该值无法修改；
   如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
   如果引用时类的成员变量，则必须当场赋值，否则编译会报错。

   2.用来修饰一个方法
      当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

  3.用来修饰类
   当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。

* **java中 Math.round（-1.5）等于多少**

  -1。四舍五入。

* **java中操作字符串的类有哪些，之间的区别**

  String 声明的是不可变的对象，每次操作都会生成新的 String 对象

  StringBuffer、StringBuilder 可以在原有对象的基础上进行操作,前者线程安全适合多线程中，后者线程不安全，多在单线程中使用

* **String str = “i" 和 String str = new String（"i"）一样吗**

  通过字面量的方式。先看常量池中是否已经存在相同字符串 (equals())，若存在，返回常量池中的引用。若不存在，在常量池中创建字符串对象并返回其引用。

  通过显式创建字符串对象的方式。先在堆中创建一个对象。再看常量池中是否已经存在相同字符串，若存在，直接返回堆中的引用。若不存在，在常量池中创建字符串对象并返回堆中的引用。

* **如何实现字符串的反转**

  ```java
      public static String reverse1(String str) {
          return new StringBuilder(str).reverse().toString();
      }
      public static String reverse2(String str) {
          String rs = "";
          char[] chars = str.toCharArray();
          for (int i = 0; i < chars.length; i++) {
              rs = chars[i] + rs;
          }
          return rs;
      }
      public static String reverse3(String str) {
          String reverse = "";
          int length = str.length();
          for (int i = 0; i < length; i++) {
              reverse = str.charAt(i) + reverse;
          }
          return reverse;
      }
  ```

  

* **String类常用的方法有哪些**

  equals：字符串是否相同
  equalsIgnoreCase：忽略大小写后字符串是否相同
  compareTo：根据字符串中每个字符的Unicode编码进行比较
  compareToIgnoreCase：根据字符串中每个字符的Unicode编码进行忽略大小写比较
  indexOf：目标字符或字符串在源字符串中位置下标
  lastIndexOf：目标字符或字符串在源字符串中最后一次出现的位置下标
  valueOf：其他类型转字符串
  charAt：获取指定下标位置的字符
  codePointAt：指定下标的字符的Unicode编码
  concat：追加字符串到当前字符串
  isEmpty：字符串长度是否为0
  contains：是否包含目标字符串
  startsWith：是否以目标字符串开头
  endsWith：是否以目标字符串结束
  format：格式化字符串
  getBytes：获取字符串的字节数组
  getChars：获取字符串的指定长度字符数组
  toCharArray：获取字符串的字符数组
  join：以某字符串，连接某字符串数组
  length：字符串字符数
  matches：字符串是否匹配正则表达式
  replace：字符串替换
  replaceAll：带正则字符串替换
  replaceFirst：替换第一个出现的目标字符串
  split：以某正则表达式分割字符串
  substring：截取字符串
  toLowerCase：字符串转小写
  toUpperCase：字符串转大写
  trim：去字符串首尾空格

* **抽象类必须有抽象的方法吗**

  no，但是如果一个类包含抽象方法，则该类必须是抽象类

* **普通类和抽象类的区别**

  抽象类不能被实例化；

  抽象方法不能被private、final、static修饰

* **接口和抽象类有什么区别**

  抽象类：可以有非抽象的方法，可以提高代码的复用性，这是抽象类的优势；

  接口：只能有抽象方法；

  java单继承、多实现。

* **java中IO流分为几种**

  字节bai流类
  抽象父类： InputStream,OutputStream

  字符流
  抽象父类：Reader, Writer

  一般操作流的步骤：
  （1）创建源
  （2）选择流
  （3）操作流（读取|写出）
  （4）释放资源

* **BIO、NIO、AIO有什么区别**

  Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。

  举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（**同步阻塞**）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（**同步非阻塞**）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（**异步非阻塞**）。

  BIO-同步阻塞 适合活动链接数不高

  NIO-同步非阻塞

  AIO-（NIO 2 jdk 7）异步非阻塞

  [详细内容参考](https://blog.csdn.net/m0_38109046/article/details/89449305)

* **String有最大长度限制吗？**

  String 的长度是有限制的。

  - 编译期的限制：字符串的UTF8编码值的字节数不能超过65535，字符串的长度不能超过65534；
  - 运行时限制：字符串的长度不能超过2^31-1，占用的内存数不能超过虚拟机能够提供的最大值。

## JVM

* **JVM内存模型**

  1.堆
  Java虚拟机所管理内存中的最大的一块，在虚拟机启动时创建，被所有线程共享。
  2.虚拟机栈

  （其中有局部变量表

  操作数栈

  动态链接）

  虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。虚拟机栈式线程所私有的，独有的，随着线程的创建而创建。每一个线程执行的方法，为该栈中的栈帧，即每一个方法对应一个栈帧。
  3.方法区

  Person p = new Person()

  方法区 栈  堆

  方法区是所有线程所共享的内存区域，在虚拟机启动的时候创建。保存类信息，静态变量
  4.程序计数器
  程序技术器占用的内存空间很小，在任意时刻，一个处理器只会执行一条线程中的指令，因此，为了线程切换后能够恢复到正确的执行位置，每条线程需要有一个独立的程序计数器（线程私有）。如果线程正在执行Java方法，则程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则这个计数器为空。
  5.本地方法栈
  如果当前线程执行的方法是Native类型，这些方法就会在本地方法栈中执行

* **GC机制和原理**[详细参考](https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html)

  - 发生区域

    堆

  - 堆内存结构

    在JDK1.8之后，堆的永久区取消了由元空间取代

    Java将堆内存分为：新生代 8:1:1（Eden、S0、S1(Survivor)三个区、老年代

    1.为什么有Survivor区？减少对象进入老年代，减少FullGC。这样设计可以使对象每熬过一次GC，增加一个年龄，到达设定值才进入老年代。

    2.为什么Survivor是两个？根据其原理，可解决内存碎片导致内存不连续的问题。

    3.为什么Survivor不是多个？会导致每个Survivor都很小，容易满。

  - 堆内存上对象的分配与回收

    可设置-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝。

    YGC（MinorGC）：频繁发生，速度快

    ​	发生在新生代。

    ​	Eden空间不足的时候发生；

    ​	一次长一岁，默认15岁，去老年代。-XX:MaxTenuringThreshold设置晋升年龄。

    ​	动态对象年龄判定：

    ​		如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该对象年龄的对象即可晋升		到老年代，不必要等到-XX:MaxTenuringThreshold。

    ​	空间分配担保：

    ​		发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次		Full GC（老年代GC），如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次		Minor GC，如果不允许，则改为进行一次Full GC。

    *（可忽略）MajorGC：很少发生，速度慢

    ​	发生在老年代。发年代空间不足时发生。

    FullGC：很少发生，速度慢

    ​	看作包含以上两种GC。发生Full GC一般都会有一次Minor GC。

    ​	1.System.gc()方法的调用，此方法是建议JVM进行Full GC,虽然只是建议而非一定

    ​	2.老年代的内存空间不足

    ​	3.当Minor GC时，老年代的剩余空间小于历次从新生代往老年代中移的对象的平均内存空间大小时

    ​	4.方法区内存不足：JDK7包含7有永久代

    ​	5.堆中分配很大的对象。虽有足够空间，但是没有足够大的连续空间。

  - 标记阶段算法

    为了解决**JVM如何判定一个对象是否应该被回收**

    引用计数法：
    是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。

    优点：实现简单，垃圾对象便于标识；判定效率高，回收没有延迟性

    缺点：1、需要计数器额外占用空间；2、需要加减越算，增加时间复杂度3、（最重要的）无法解决循环引用的问题。所以java中没有使用该算法。

    可达性分析算法：

    以根节点GC Roots为起始点，按照从上而下的方式搜索被根对象集合所连接的目标对象是否可达。

  - 清楚阶段算法

    标记-清除算法（Mark-Sweep）：

    第一阶段：从引用根节点开始标记所有被引用的对象，

    第二阶段：遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。

    缺点：执行效率不稳定，会因为对象数量增长，效率变低，清除后内存不连续，产生内存碎片。需要维护一个空闲列表。

    优点：简单

    复制（Copying）算法：

    复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。

    优点：没有标记和清除过程，实现简单，运行高效；空间连续，不会有碎片问题。
    缺点：需要两倍内存空间。如果系统中存活对象特别多，这个算法也不理想。

    标记-压缩（标记-整理，Mark-Compact）算法：

    标记-整理算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，

    第一阶段从根节点开始标记所有被引用对象，

    第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。

    优点：内存连续，分配新对象，jvm只需要持有一个内存的起始地址即可。不必内存减半
    缺点：相比其他效率最差。移动对象时，如果对象被其他对象引用，则还需要调整引用的地址；移动过程中，需要暂停用户应用程序。即STW

    最好的算法？
    分代收集算法：
    年轻代：朝生夕死，存活率低，回收频繁。复制算法
    老年代：多数都是存活的，回收不频繁，标记清除或标记清除和标记整理混合使用
    Mark阶段的开销与存活对象数量成正比；
    Sweep阶段的开销与所管理的区域的大小成正相关。
    Compact阶段的开销与存活对象的数据成正比。
    增量收集算法：分阶段标记-清除和标记-整理，不用Stop the World
    缺点是线程转换，上下文转换，成本上升，系统吞吐量下降
    分区算法
    将堆空间划分为连续的独立的小空间，每个小区间独立使用独立回收
    好处：可以控制一次回收多少个小区间

* **垃圾收集器**

  ![](https://img2020.cnblogs.com/blog/1863208/202005/1863208-20200518221710647-576582447.png)

  * **1、Serial收集器：**

    Serial收集器是**一个单线程的垃圾收集器**，并且在执行垃圾回收的时候需要 **Stop The World**。虚拟机运行在**Client模式**下的默认新生代收集器。Serial收集器的优点是简单高效，对于限定在单个CPU环境来说，Serial收集器没有多线程交互的开销。缺点：交互较强的应用不行，STW久

    复制算法

    **2、Serial Old收集器：**

    Serial Old是Serial收集器的老年代版本，也是**一个单线程收集器**。主要也是给在Client模式下的虚拟机使用。在Server模式下存在主要是做为CMS垃圾收集器的后备预案，**当CMS并发收集发生Concurrent Mode Failure时使用。**

    标记-整理

    **3、ParNew收集器：**

    ParNew是Serial收集器的**多线程**版本，新生代是并行的（多线程的），可以使用参数：**-XX：UseParNewGC使用该收集器，使用 -XX：ParallelGCThreads可以限制线程数量。**

    复制算法

    **4、Parallel Scavenge垃圾收集器：**

    Parallel Scavenge是一种新生代收集器，而且是**并行的多线程收集器。**Paralle收集器特点是更加关注吞吐量（吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值）。可以通过**-XX:MaxGCPauseMillis参数控制最大垃圾收集停顿时间；通过-XX:GCTimeRatio参数直接设置吞吐量大小；通过-XX:+UseAdaptiveSizePolicy参数可以打开GC自适应调节策略，**该参数打开之后虚拟机会根据系统的运行情况收集性能监控信息，动态调整虚拟机参数以提供最合适的停顿时间或者最大的吞吐量。**自适应调节策略**是Parallel Scavenge收集器和ParNew的主要区别之一。

    复制算法

    **5、Parallel Old收集器：**

    Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

    **6、CMS（Concurrent Mark Sweep）收集器（并发标记清除）**

  CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种老年代收集器，通常与**ParNew**一起使用。

  **CMS的垃圾收集过程分为4步：**

  - **初始标记**：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。

    - **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。

  - **重新标记**：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。

    - **并发清除**：和用户线程并发执行的，基于标记结果来清理对象。

     ![img](https://img2020.cnblogs.com/blog/1863208/202005/1863208-20200518221735413-1771145268.png)

     

     

    那么问题来了，**如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？**

    答：不会的，在并发标记阶段其实还包括了一次并发的**预清理阶段**，虚拟机会主动**等待年轻代发生垃圾回收**，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。

    #### **CMS垃圾回收器的优缺点分析：**

    CMS以降低垃圾回收的停顿时间为目的，很显然其具有并发收集，停顿时间低的优点。

    #### **缺点主要包括如下：**

    - **对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。

  - 收集过程中会产生**浮动垃圾**，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。

    - **标记-清除方式会产生内存碎片**，可以使用参数**-XX：UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。参数**-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

    接下来，我们先看下上边介绍的浮动垃圾是怎么产生的吧。

    **浮动垃圾：**

    由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了**“Floating Garbage”**，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，**并发收集器一般需要20%的预留空间**用于这些浮动垃圾。

    并发标记阶段如果产生新垃圾，无法对其标记。只能下次gc了。（Remark是把之前标记为垃圾的，修改为不是垃圾，而不是垃圾的，没有处理）

    **7、G1（Garbage-First）收集器：**

  G1收集器将新生代和老年代取消了，取而代之的是**将堆划分为若干的区域**，每个区域都可以根据需要扮演新生代的Eden和Survivor区或者老年代空间，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。

  通过**将JVM堆分为一个个的区域（region）**,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次**根据回收时间来优先回收价值最大的region。**

    **G1收集器的特点：**

    - **并行与并发**：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。

  - **分代收集**：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。

    - **空间整合**：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。
    - **可预测的停顿**：能够建立可以预测的停顿时间模型，预测停顿时间。

    **和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：**

    - 初始标记
    - 并发标记
    - 最终标记
    - 筛选回收

    其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。

    java -XX:+PrintCommandLineFlags -version

    jdk1.8默认的新生代垃圾收集器：Parallel Scavenge，老年代：Parallel Old

    jdk1.9 默认垃圾收集器G1

* **JVM中几种classloader，为什么会有多种**

  启动类加载器（Bootstrap ClassLoader 根加载器）

  ​	它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

  扩展类加载器（Extension ClassLoader）

  ​	它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。继承抽象类ClassLoader

  应用程序类加载器(Application ClassLoader也叫系统类加载器 System ClassLoader)

  ​	负责加载用户类路径(classpath)上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

  ​	还可以自定义类加载器

  1.加载

  ​	指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象

      类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
      
      通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。

  2.链接

  ​	验证：

  ​	准备：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。

  ​	解析

  3.初始化

  ​	初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。

* **类加载 过程**

  类加载器加载Class大致要经过如下8个步骤：

  检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
  如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
  请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
  请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
  当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
  从文件中载入Class，成功后跳至第8步。

* **类记载机制**

  全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
  双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。
  缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。

* **什么是双亲委派机制？介绍一下运作流程，双亲委派模型的好处，什么情况下需要破坏双亲委派模型**

  * 双亲委派机制：

  <img src="https://images2015.cnblogs.com/blog/731716/201607/731716-20160701132830015-300463923.png" style="zoom:50%;" />

  上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。

  * 好处

    1.避免类的重复加载（父加载器加载过，就不用再加载）

    2.可以防止核心API库被随意篡改。

  * 破坏双亲委派模型

    打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。

    使用线程上下文类加载器

    第一次被破坏

    ​	因为双亲委派模型是JDK1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时就已经存在，所以在面对已存在的用户自定义类加载器的实现代码时，Java设计者引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，这是源于虚拟机进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。

    第二次被破坏

    ​	如JNDI服务，使用线程上下文类加载器

    第三次被破坏

    ​	由于用户对程序的动态性的追求导致的，例如OSGi的出现。在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构。

* **常见的JVM调优工具有哪些**

  Jconsole : jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。详细说明参考这里

  JProfiler：商业软件，需要付费。功能强大。详细说明参考这里

  VisualVM：JDK自带，功能强大，与JProfiler类似。推荐。

* **常见的JVM调优方法有哪些，可以具体到调整哪个参数，调成什么值**

  * 查出问题

    内存：检查内存释放情况、老年代年轻代分配是否合理、内存泄露、垃圾回收算法是否合理

    线程：线程状态监控、死锁。

    热点分析：

    ​	CPU热点：那些方法占用CPU时间多、

    ​	内存热点：那些对象占用内存多

  * 解决问题

    * 将新对象预留在新生代

    * 将大对象放入老年代：因为大对象进入新生代，放不下会导致小对象进入老年代，扰乱了GC。

    * 设置对象进入老年代的合适年龄

    * 稳定与震荡的堆大小。稳定的堆大小对垃圾回收是有利的，获得一个稳定堆大小的方法就是设置 -Xmx 和 -Xms 一样的值。不稳定的堆也不是木有用处，让堆大小在一个区间内震荡，在系统不需要使用大内存时压缩堆空间，使 GC 应对一个较小的堆，可以加快单次 GC 的速度。基于这种思想，JVM 提供了两个参数用于压缩和扩展堆空间，参数如下：

      -XX：MinHeapFreeRatio：设置堆空间最小空闲比例，默认是 40 ，当堆空间的空闲比例小于这个值时，JVM 便会扩展堆空间

      -XX：MaxHeapFreeRatio：设置堆空间的最大空闲比例，默认是 70，当堆空间的空闲比例大于这个值时，JVM 便会压缩堆空间，得到一个较小的堆

      注意：当 -Xms 和 -Xmx 相等时，-XX：MinHeapFreeRatio 和 -XX：MaxHeapFreeRatio 这两个参数无效

    * 吞吐量优先设置

      机器配置是 4G 内存 和 32 核 CPU，配置参数如下：

      -Xms3800m  -Xmx3800m（堆的初始值和最大值一样） 

      -Xmn2g（新生代大小）

      -Xss128k（线程栈大小，减少它使剩余的系统内存支持更多的线程） 

      -XX：+UseParallelGC（新生代使用并行回收收集器）

       -XX：ParallelGCThreads=20（垃圾回收的线程数）

       -XX：+UseParallelOldGC （老年代使用并行回收收集器）

    * 使用大页案例

      使用大的内存分页可以增强 CPU 的内存寻址能力，从而提高系统的性能，参数设置如下：

      -XX：LargePageSizeInBytes：设置大页的大小

    * 降低停顿案例

      为了降低应用软件在垃圾回收时的停顿，首先考虑的使用关注系统停顿的 CMS 回收器，为了减少 Full GC 的次数，应尽可能将对象预留在新生代，新生代 Minor GC 的成本远远小于老年代的 Full GC

      -Xms3800m  -Xmx3800m（堆的初始值和最大值一样） 

      -Xmn2g（新生代大小）

      -Xss128k（线程栈大小，减少它使剩余的系统内存支持更多的线程）

      -XX：ParallelGCThreads=20（垃圾回收的线程数）

      -XX：+UseConcMarkSweepGC（老年代使用 CMS 收集器）

       -XX：+UseParNewGC（新生代使用并行收集器）

      -XX：SurvivorRatio=8（设置 eden ： survivor = 8 : 1）

      -XX：TargetSurvivorRatio（设置 survivor 的使用率为 90%，默认是50%，提高了survivor 区的使用率，当存放的对象超过这个数值，则对象会向老年代压缩）

      -XX：MaxTenuringThreshold=31（设置年轻对象晋升到老年代的最大年龄是31，默认是15，设为31是尽可能地将对象留在新生代

    * 常用JVM设置参数

      1、JIT编译参数

      JVM 的 JIT（Just-In-Time）编译器，可以在运行时将字节码编译成本地代码，从而提高函数的执行效率。参数设置如下

      -XX：CompileThreshold：JIT 编译的阀值，当函数的调用超过这个值时，JIT 就将字节码编译成本地机器码。在 client 模式下，取值是 1500，在 server 模式下，取值是 10000

      2、堆快照（堆 Dump）
      	-XX：+HeapDumpOnOutOfMemoryError（开启堆快照）

      ​	-XX：HeapDumpPath=C:/m.hprof（保存文件到哪个目录）

      3、错误处理

      系统发生 OOM 错误时，JVM 在错误发生时运行一段第三方脚本，重置系统，设置参数如下：

      -XX：OnOutOfMemoryError=C:\reset.bat


      4、获取 GC 信息

      获取 GC 信息是 java 应用程序调优最重要的一环，下面介绍一些常用的设置参数：

      -XX：+PrintGC（-verbose：gc）：输出打印简要的 GC 信息，包括 GC 前的堆栈情况和 GC 后的堆栈大小和堆栈的总大小

      -XX：+PrintGCDetails：输出打印详细的 GC 信息，不仅包括基本信息，还给出了新生代、老年代和永久区各自的 GC 信息

      -XX：+PrintGCTimeStamps：额外输出 GC 发生的时间，可以推断出 GC 的频率和间隔

      -XX：+PrintTenuringDistribution  -XX：MaxTenuringThreshold=18：查看新生代晋升老年代的实际阀值（-XX：+PrintTenuringDistribution），设置的最大年龄为18（ -XX：MaxTenuringThreshold=18）

      -XX：+PrintHeapAtGC：每次 GC 时都会打印堆的详细使用情况，输出量很巨大。它分为两个部分：GC 前的堆信息和 GC 后的堆信息，这里包含了新生代、老年代和永久区的使用大小和使用率，还包括了新生代中 eden 区和 survivor 区的使用情况

      -XX：+PrintGCApplicationStoppedTime：应用程序在 GC 发生时的停顿时间

      -XX：+PrintGCApplicationConcurrentTime：应用程序在 GC 停顿期间的执行时间

      -Xloggc：C:/gc.log：将 GC 日志信息输出到具体位置的文件中，便于日后日志分析

      注意：详细的 GC 信息是进行 JVM 调优的重要参考信息，可以根据 GC 日志，设置合理的堆大小及相关垃圾回收器的参数


      5、类和对象跟踪

      JVM 提供了一组参数，用于获取系统运行时加载、卸载类的信息，参数设置如下：

      -XX：TraceClassLoading：跟踪类加载情况

      -XX：TraceClassUnloading：跟踪类的卸载情况

      -verbose：class：相当于同时设置  -XX：TraceClassLoading 和 -XX：TraceClassUnloading 两个参数

      -XX：+PrintClassHistogram：打印运行时实例的信息，当设置此参数后，使用 Ctrl +    Break 会输出系统内类的统计信息，从左到右依次显示了序号、实例数量、总大小和类名等信息


      6、控制GC

      -XX：DisableExplicitGC：禁止 GC 操作，即禁止在程序中使用 System.gc() 触发 Full GC

      -Xnoclassgc：禁止类的回收

      -Xingc：增量式的 GC ，增量式的 GC 使用特定的算法让 GC 线程和应用程序线程交叉执行，从而减少应用程序因 GC 产生的停顿时间

      -Xverify：none：关闭类校验器

      -XX：+UseLargePages：启用大页，使用大页后，内存分页的表项就会减少，从而提升CPU从虚拟内存地址映射到物理内存地址的能力

      -XX：LargePageSizeInBytes：指定大页的大小

* **int a = 1;jvm如何取得a的值**

  1 a作为类的成员变量，存放于方法区中；1保存在堆(Heap)的实例中
  2 a作为方法局部变量，存放于Java虚拟机栈(JVM Stacks)的局部变量表中；1也保存在栈内存中

* **逃逸分析**

  逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。

  如果开启JVM逃逸分析可以优化JVM，但是目前不成熟。

  ​	一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

  ​	二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。节省对内存减少GC。

  ​	三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

  ​			标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

  在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

  public static void main(String[] args) {
     alloc();
  }

  private static void alloc() {
     Point point = new Point（1,2）;
     System.out.println("point.x="+point.x+"; point.y="+point.y);
  }
  class Point{
      private int x;
      private int y;
  }
  以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。

  以上代码，经过标量替换后，就会变成：

  private static void alloc() {
     int x = 1;
     int y = 2;
     System.out.println("point.x="+x+"; point.y="+y);
  }
  可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

  标量替换为栈上分配提供了很好的基础。
  
  

  在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，

  -XX:+DoEscapeAnalysis ： 表示开启逃逸分析

  -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis

* **jvm调优调的哪些参数？我说初始堆大小和最大堆大小一样，问这样有什么好处**

  主要调：堆的初始和最大内存（堆的最小和最大空闲时间）（新生代的大小）、线程栈的大小、垃圾收集器的选择。

  设置初始和最大堆一样的好处：

  ​	一般情况下，在生产环境中，初始堆大小-Xms与最大堆大小-Xmx被设置为相等。假设如果在生产环境中，初始堆大小-Xms与最大堆大小-Xmx是不等的，那么JVM就会根据堆内存的使用情况，动态的向操作系统申请内存，扩大或者是缩小，以-Xmx和-Xms的值为上下界，这里的每一次调整都会产生一定的系统开销，虽然做到了动态申请堆大小的能力，不过生产环境中，很少说一台机器跑好多个JAVA程序，一般情况下都是一对一，那么动态申请调整堆大小就没有意义了，因为不管内存申请的多还是少，都只是这个JAVA程序在用，不需要给其他的程序腾出空间，相反的，如果把初始堆大小-Xms与最大堆大小-Xmx设置成不相等，那么反而画蛇添足，因为如果初始堆大小-Xms与最大堆大小-Xmx不相等，那么就会需要申请空间时，而每次申请空间，就会产生相应的系统开销，同时如果一开始堆大小是-Xms，会增加程序运行时进行垃圾回收的次数，降低程序的性能。

  

## 容器

* **Collection和Collections有什么区别**

  ![](https://img-blog.csdnimg.cn/20200410211055784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTM2NTc4,size_16,color_FFFFFF,t_70)

  1、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。

  List，Set，Queue接口都继承Collection。
  直接实现该接口的类只有AbstractCollection类，该类也只是一个抽象类，提供了对集合类操作的一些基本实现。List和Set的具体实现类基本上都直接或间接的继承了该类。

  2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等），大多数方法都是用来处理线性表的。此类不能实例化，就像一个工具类，服务于Java的Collection框架。

* **HashMap和HashTable区别**

  * 父类不同

    HashTable：继承自Dictionary（已被废弃）

    HashMap：继承自AbstractMap类

    不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。

    Hashtable比HashMap多提供了elments() 和contains() 两个方法。

        elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。

       contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。

  * null值问题

    HashTable：不能有null值null键

    HashMap：可以有一个null值，支持null键。

    当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

  * 线程安全性

    HashTable：线程安全，它的每个方法中都加入了Synchronize方法。

    ​	但基本由于性能问题，已被弃用。ConcurrentHashMap因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。

    HashMap：单线程使用性能更好，多线程不安全，还可能造成死锁。

  * 遍历方式不同

  * 初始容量不同

    Hashtable的初始长度是11，之后每次扩充容量变为之前的2n+1（n为上一次的长度）

    而HashMap的初始长度为16，之后每次扩充变为原来的两倍

    创建时，如果给定了容量初始值，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。

  * 计算hash值方式不同

    为了得到元素的位置，首先需要根据元素的 KEY计算出一个hash值，然后再用这个hash值来计算得到最终的位置

    Hashtable直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。 然而除法运算是非常耗费时间的。效率很低

    HashMap为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。

* **如何决定使用HashMap还是TreeMap**

  HashMap基于散列桶（数组和链表）实现；TreeMap基于红黑树实现。
  HashMap不支持排序；TreeMap默认是按照Key值升序排序的，可指定排序的比较器，主要用于存入元素时对元素进行自动排序。
  HashMap大多数情况下有更好的性能，尤其是读数据。在没有排序要求的情况下，使用HashMap。
  都是非线程安全。

* **HashMap数据结构和实现原理，以及有什么并发问题**

  [详细参考](https://juejin.cn/post/6844903646212128776)

  * 公共：

    * 负载因子：0.75

    ​		为什么是0.75？ 

    ​			时间和空间的权衡。如果为1，增加了hash冲突，增加了红黑树的复杂度。如果为0.5，hash冲突降低了，浪费了更多的空间。

    ​			源码上说了，负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。

    * 初始容量：16 

    ​		若指定容量，变成他的2的指数次幂。（为了性能，尽量提前预估大小，而且要考虑实际元素大小要 小于 HashMap算得2指数次幂*0.75，否则容易触发扩容机制）

    ​		为什么2的指数次幂容量，及二倍扩容？

    ​			计算索引：当 length 为 2 的次幂时，num & (length - 1) = num % length 等式成立，位运算更高效

    * 共有的并发问题：

    ​		并发扩容导致形成环形链表，导致死循环。

    ​		解决方式：避免扩容。

    * rehash：

      扩容导致时，将原有的对象重新计算hash值重新的分配并加入新的桶内。

      目的：为了解决数量增多，导致一些链表太长，时间复杂度O(n)的问题

  * 1.7

    * 插入方式：头插

    * 数据结构：数组+链表

    * 节点：Entry

    * 这是什么？index = hash&length-1，所有hash低位相同，高位不同导致hash冲突，性能保险，再次进行一种算法的hash运算。

    * put（）过程：

      		1.判断当前数组是否需要初始化。
      	  2.如果 key 为空，则 put 一个空值进去。
      	  3.根据 key 计算出 hashcode。
      	  4.根据计算出的 hashcode 定位出所在桶。
      	  5.如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。
      	  6.如果桶是空的，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。
      		7.当调用 addEntry 写入 Entry 时需要判断是否需要扩容。
      	    如果需要就进行两倍扩充，并将当前的 key 重新 hash 并定位。
      	    而在 createEntry 中会将当前位置的桶传入到新建的桶中，如果当前桶有值就会在位置形成链表。

    * 扩容时机：

      ​		先判断扩容，后插入。

      ​			为什么这个顺序？因为JDK7头插，如果先插入后扩容，而扩容时还要遍历元素，重新整顿，没必要先插入。

      ​		(size>=threshold)&&(null !=table[bucketIndex])
      ​        1、 存放新值的时候当前已有元素的个数必须大于等于阈值
      ​		2、 存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值换算出来的数组下标位置已经存在值）

  * 1.8

    * 插入方式：尾插

      ​	为什么尾插？为了使用二叉树。

    * 数据结构：数组+链表+红黑树

      ​	红黑树时间复杂度O(logn)

    *  节点：Node

    * 计算hash：

      包含算hash值时高是16位与低16进行了异或运算

    * put（）过程：

    		1.判断当前桶为空，为空初始化。
    	
    		2.计算key的hashcode，定位具体的桶，若痛为null，则没有hash冲突，直接创建一个新桶即可。
    	
    		3.若桶不为空（hash冲突），则比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e，
    	
    		4.若不相等，如果当前桶为红黑树，按照红黑树方式写入数据。
    	
    		5.如果当前桶为链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面
    	
    		6.接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。
    	
    		7.如果在遍历过程中找到 key 相同时直接退出遍历。
    		8.如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。
    		9.最后判断是否需要进行扩容。（插入后的size>阈值）

    * 扩容时机：

      先插入，后判断扩容

      ​	为什么这个顺序？因为JDK8尾插，如果先扩容后，而插入时还要遍历元素，扩容还要遍历一遍，没必要遍历两次啊。

      插入后的size>阈值。

    * 树化机制

      阈值：当前链表长度大于8

      ​	为什么是8？源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。

      条件：先判断table的长度是否大于64 && 链表长度超过阈值

    * 树退化机制

      阈值：当前树节点数小于6

      ​	为什么是6？避免来回转化。

      ​	因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。

      条件：

      ​	1.remove():

      ​	在红黑树的root节点为空 或者root的右节点、root的左节点、root左节点的左节点为空时 说明树都比较小了

      ​	2.resize():

      ​	当红黑树节点元素小于等于6时(只有resize()才用到了这个6)

* **ConcurrentHashMap的原理**

  * 1.7

    是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。

    分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。

  * 1.8

    抛弃了原有的 Segment 分段锁，节点改为Node，数组加链表+红黑树，而采用了 CAS + synchronized 来保证并发安全性。

* **LinkedHashMap的应用**

* **HashSet实现原理**

* **ArrayList和LinkedList区别**

* **如何实现数组和List之间的转化**

* **ArrayList和Vector区别**

* **Array和ArrayList区别**

* **Queue中poll()和remove()区别**

* **哪些集合类是线程安全的**

* **迭代器Iterator是什么？怎么使用，有什么特点？**

* **Iterator和ListIterator的区别**

* **怎么确保一个集合不能被修改**

## 异常

* **throw和throws区别**
* **final、finally、finalize有什么区别**
* **try-catch-finally中，如果catch中return了，finally还是执行吗**
* **捕获异常在catch块里一定会进入finally吗？catch里能return吗？catch里return还会进finally吗？在try里return呢是什么情况？**
* **常见的异常类有哪些**

## 网络

* **http状态码，以及301和302区别**
* **forward和redirect的区别**
* **简述tcp和udp的区别**
* **tcp为什么三次握手，两次不行吗**
* **说一下tcp的粘包是怎么产生的**
* **OSI的7层模型都有哪些**
* **get和post的请求有哪些区别**
* **如何实现跨域**
* **JSONP实现原理**

## Spring

* **spring有哪些优势**
* **有没有读过源码，有没有进行解析，再封装**
* **Spring5比Spring4做了哪些改进**
* **spring有哪些常用注解？（我一紧张说了springboot的注解）**

## SpringBoot

* **什么是springboot，为什么要用springboot**
* **springboot的核心配置文件是什么，有哪几种类型，及区别**
* **springboot实现热部署的方式**
* **springboot比spring做了哪些改进**

## SpringCloud

* **什么是springcloud？核心组件有哪些？**
* **springcloud的断路器的作用**
* **Feign客户端的远程调用是怎么实现的?协议是什么？Hystrics熔断保护的实现原理？**

## Dubbo

* **springcloud和dubbo如何选择，什么场景下使用springcloud**
* 

## 设计模式

* **说一下熟悉的设计模式**
* **简单工厂和抽象工厂的区别**

## SpringMVC

* **springMVC原理**
* 

## Mybatis

* **#{}和${}区别**
* **mybatis中有几种分页方式**
* **RowBounds是一次性查询全部结果吗？为什么？**
* **mybatis中逻辑分页和物理分页的区别**
* **mybatis是否支持延迟加载？延迟加载的原理**
* **说一下mybatis的一级缓存和二级缓存**
* **mybatis和hibernate的区别**
* **mybatis有哪些执行器（Executor发音？）**
* **mybatis分页插件的实现原理**
* **mybatis如何编写一个自定义插件**

## 多线程

* **并行和并发的区别**
* **线程和进程**
* **守护线程是什么**
* **创建线程有哪几种方式**
* **runnable和callable**
* **线程有哪些状态，线程的生命周期，什么时候会出现进程僵死**
* **什么是线程安全，如何实现线程安全**
* **sleep()和wait()的区别**
* **notity()和notifyAll()的区别**
* **线程的run()和start()的区别**
* **为什么需要线程池**
* **创建线程池有哪几种方式**
* **线程池的几个重要参数，如何合理配置线程池的大小**
* **线程池的实现原理和线程的调度过程**
* **线程池有哪些状态**
* **线程池的submit()和execute()的区别**
* **在java程序中怎么保证多线程的运行安全**
* **多线程锁的升级原理**
* **什么是死锁，该怎么防止**
* **ThreadLocal是什么，原理，有哪些使用场景**
* **ThreadLocal什么时候会出现OOM，为什么**
* **volatile是什么，原理，有哪些使用场景**
* **说下synchronized底层实现原理**
* **synchronized锁粒度，原子性和可见性**
* **sychronized和volatile区别**
* **sychronized和Lock区别**
* **sychronized和ReentrantLock区别是什么**
* **说一下atomic的原理**
* **知道哪些锁？公平锁和非公平锁区别？可重入锁是什么？我说是sychronized里还有个synchronized**

## 反射

* **什么是反射**
* **什么是java序列化？什么情况下需要序列化**
* **动态代理是什么？有哪些应用？**
* **怎么实现动态代理**

## 对象拷贝

* **为什么要使用克隆**
* **如何实现克隆**
* **深拷贝和浅拷贝的区别**

## Java Web

* **cookie和session的区别及各自原理**
* **如果客户端禁止cookie能实现session还能用吗**
* **什么XSS攻击，怎么避免**
* **什么是CSRF（跨站请求伪造）攻击，怎么避免**
* **单点登录的原理，你们jwt（json web token）中包含哪些信息？**
* **项目中的搜索功能是怎么实现的？ES+kibana  ik分词**
* **elasticsearch的主从、字符串类型是哪个、nested类型是什么、聚合怎么写、查询某个id的语句、创建es的索引、时间类型怎么存的（我说了个utc...他说utc的话你的时间得+8，我蒙了）**
* **引入第三方登录时，怎么使得你自己的token和第三方的token关联起来？**

## 数据库MySql

* **如何避免sql注入**
* **数据库的三范式**
* **一张自增表里共有7条数据，删除了最后2条，重启mysql，有插入了一条数据，此时id是几**
* **如何获取当前数据库的版本**
* **说一下ACID是什么**
* **char和varchar的区别**
* **float和double的区别**
* **mysql的内、左、右连接的区别**
* **mysql的索引是怎么实现的**
* **怎么验证mysql的索引是否满足需求**
* **说一下数据库的事务隔离**
* **说一下mysql常用的引擎**
* **说一下mysql的行锁、表锁、共享锁、排他锁**
* **乐观锁和悲观锁，实现方式，业务场景**

## Redis

* **是什么？有哪些使用场景**
* **有哪些功能，Redis的有哪些模式？**
* **redis为什么这么快？**
* **redis和memecache的区别**
* **redis为什么是单线程的**
* **redis采用多线程会有哪些问题**
* **什么是缓存穿透。。。如何解决**
* **redis支持的数据类型**
* **redis支持的java客户端有哪些**
* **jedis和redission有哪些区别**
* **怎么保证缓存和数据库数据的一致性**
* **redis的持久化策略**
* **redis怎么实现分布式锁，redis分布式锁操作的原子性，redis内部如何实现的**
* **redis分布式锁有什么缺陷**
* **redis如何做内存优化**
* **redis的淘汰策略有哪些**
* **redis的常见性能问题有哪些？该怎么解决**
* **redis主从原理**

## 分布式

### 分布式事务

* **谈谈对分布式事务的理解**
* **场景的解决方案有哪些**
* **什么是两阶段提交、三阶段提交**

### 其他

* **有没有写过分布式的业务，分布式存储？你觉得分布式的话会遇到什么问题呢？**

* 

## 消息中间件

### kafka

* **kafka可以脱离zk单独使用吗？为什么**
* **kafka有几种数据保留的策略**
* **kafka同时设置了7天和10G清除数据，到第五天的时候达到了10G，这个时候kafka如何处理**
* **什么情况下，会导致kafka运行变慢**
* **使用kafka集群需要注意什么**

### RabbitMQ

省略了rabbitmq

* **使用场景**
* **有哪些重要的角色**
* **有哪些重要的组件**
* **vhost的作用**
* **消息是怎么发送到的**
* **怎么保证消息的稳定性**
* **怎么避免消息丢失**
* **要保证消息持久化成功的条件有哪些**
* **持久化有什么缺点**
* **有几种广播类型**
* **怎么实现延迟消息队列**
* **集群有什么用**
* **集群搭建需要注意哪些问题**
* **节点的类型有哪些**
* **每个节点是其他节点的完整拷贝吗？为什么？**
* **集群中唯一一个磁盘节点崩溃了会发生什么情况**
* **对集群节点停止顺序有要求吗**
* **MQ怎么知道消息被指定的消费者消费？怎么使不同的生产者生产的消息被不同的消费者消费？**
* **mq中一条消息出现了异常，怎么处理**
* **mq1000个消息始终不被消费怎么处理（我说不处理...她笑了）**

### 其他问题

* **了解几种消息中间件产品？各产品有缺点介绍**
* **消息中间件如何保证消息的一致性和如何进行消息的重试机制**

## 数据结构和算法

* **红黑的实现原理和场景**
* **给你两个二叉搜索树，如何使用线性的时间复杂度，将他们合并成一颗二叉搜索树**
* **给定一个二叉搜索树，编写一个函数kthSmallest来查找其中第k个最小的元素**
* **给定一个二叉树，找到该树中两个指定节点的最近公共祖先**
* **二叉树的序列号和反序列化**
* **如何找出一个单项链表的中间元素**
* **写一个函数，打印树的中序遍历**
* **用java写一个方法，判断一个树是否是二叉搜索树**
* **用java写一个方法，判断一个树是否是平衡树**
* **用java实现二分搜索算法**
* **用java实现插入排序**
* **用java实现冒泡排序**
* **实现从一个数组中移除重复元素**
* **如何找出最大和最小的数在一个数组中**
* **为什么char数组能比String更好的去存储password**
* **给你一个长度为n的数组，其中只有一个数字出现了奇数次，其他均出现偶数次，问，如何使用优秀的时空复杂度快速找到这个数字**
* **给你一个长度为n的数组，其中只有一个数字出现了大于等于n/2次，问，如何使用优秀的时空复杂度快速找到这个数字**
* **一个包含1-100数字的数组中，有一个数字丢失了，如何快速找出它